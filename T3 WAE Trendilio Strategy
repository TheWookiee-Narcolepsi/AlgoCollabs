//@version=6
strategy("T3 WAE Trendilio Strategy 1.5.2", overlay=true, calc_on_every_tick=false, calc_on_order_fills=false, initial_capital= 1000000, slippage= 13, process_orders_on_close= false, use_bar_magnifier= true, default_qty_type=strategy.percent_of_equity, default_qty_value= 100, commission_value=0.05, pyramiding=1, margin_long= 0, margin_short= 0)

// ------------------------------------------------
// Version Settings
// ------------------------------------------------
var g_version = "🔖Version Info🔖"
version = input.string("1.5.2", "Version", options=["1.5.2"], group=g_version, tooltip="Version of plate")
optimizingTime = input.bool(true,"Optimizing Time",group=g_version, tooltip="When enabled, the script will skip non-essential visuals (dashboard, labels, etc.) for faster loading.")

// ------------------------------------------------
// 1) Main Strategy Settings
// ------------------------------------------------
var g_main_strategy = "🌟Master Strategy Setup🌟"
useT3 = input.bool(true, "#1 T3 MA", group=g_main_strategy, tooltip="Enable/disable the T3 indicator for strategy signals.")
t3Length = input.int(156, "T3 Length", minval=1, group=g_main_strategy, tooltip="Set the period length for the T3 indicator.")
t3Factor = input.float(1.7, "T3 Smoothing Factor", minval=0.01, group=g_main_strategy, tooltip="Set the smoothing factor for the T3 indicator, affecting its sensitivity.")
highlightT3 = input.bool(true, "Visualize T3 Shifts", group=g_main_strategy, tooltip="Enable visual highlights for T3 movements on the chart.")
t3Source = input.string("close", "T3 Source", options=["open","high","low","close","hl2","hlc3","ohlc4","hlcc4"], group=g_main_strategy, tooltip="Select the price source for the T3 indicator.")
useTrendilio = input.bool(true, "#2 Integrate Trendilio", group=g_main_strategy, tooltip="Enable/disable the Trendilio indicator for strategy signals.")
TrendilioSource = input.string("close", "Trendilio Source", options=["open","high","low","close","hl2","hlc3","ohlc4","hlcc4"], group=g_main_strategy, tooltip="Select the price source for the Trendilio indicator.")
smoothTrending = input.int(2, "Trendilio Smoothing", minval=1, step=1, group=g_main_strategy, tooltip="Set the smoothing period for Trendilio trending calculations.")
lookbackTrendilio = input.int(31, "Trendilio Lookback", minval=1, group=g_main_strategy, tooltip="Set the lookback period for Trendilio calculations.")
almaOffsetTrend = input.float(1.2, "ALMA Offset - Trendilio", minval=0.01, step=0.01, maxval=10, group=g_main_strategy, tooltip="Set the offset for the Arnaud Legoux Moving Average (ALMA) in Trendilio.")
almaSigma = input.int(10, "ALMA Sigma - Trendilio", minval=1, group=g_main_strategy, tooltip="Set the sigma value for the ALMA in Trendilio, controlling its smoothing.")
bandMultiplier = input.float(0.7, "Trendilio Band Multiplier", minval=0.1, step=0.1, group=g_main_strategy, tooltip="Set the multiplier for Trendilio's band width, affecting overbought/oversold zones.")
customBandLengthTrendilio = input.bool(false, "Use Custom Band Length", group=g_main_strategy, tooltip="Enable a custom band length for Trendilio, otherwise use the lookback period.")
customBandLengthTrendilioValue = input.int(20, "Custom Band Length Value", minval=1, group=g_main_strategy, tooltip="Set the custom band length for Trendilio if custom length is enabled.")
trendilioTradeType = input.string("OS/OB enter", "Trendilio Behavior", options=["OS/OB","OS/OB enter","OS/OB exit","OS/OB reverse","OS/OB enter reverse","OS/OB reverse exit"], group=g_main_strategy, tooltip="Select the Trendilio trade type: overbought/oversold zones or various entry/exit/reverse strategies.")
useWAE = input.bool(true, "#3 Engage Weighted Alpha Envelope", group=g_main_strategy, tooltip="Enable/disable the Weighted Alpha Envelope (WAE) indicator for strategy signals.")
useExplosionLine = input.bool(true, "Alternate WAE Explosion Line", group=g_main_strategy, tooltip="Enable the explosion line instead of the standard WAE threshold for signals.")
waeSensitivity = input.int(204, "WAE Sensitivity", minval=1, group=g_main_strategy, tooltip="Set the sensitivity factor for the WAE indicator, impacting signal strength.")
fastEMALength = input.int(25, "WAE Fast EMA Length", minval=1, group=g_main_strategy, tooltip="Set the period length for the fast EMA in WAE calculations.")
slowEMALength = input.int(335, "WAE Slow EMA Length", minval=1, group=g_main_strategy, tooltip="Set the period length for the slow EMA in WAE calculations.")
bbChannelLength = input.int(46, "WAE Bollinger Channel Length", minval=1, group=g_main_strategy, tooltip="Set the period length for the Bollinger Bands channel in WAE.")
bbStdevMultiplier = input.float(2.1, "WAE Bollinger StDev", minval=0.1, step=0.1, group=g_main_strategy, tooltip="Set the standard deviation multiplier for Bollinger Bands in WAE, controlling channel width.")
noTradeZoneThreshold = input.int(31, "WAE No-Trade Threshold", minval=1, group=g_main_strategy, tooltip="Set the threshold for the no-trade zone in WAE, filtering out low-confidence signals.")
force_exit = input.bool(false, "Forceful Exit on Signal", group=g_main_strategy, tooltip="Enable to force exit positions when an exit signal is generated, regardless of profit or loss.")

// ------------------------------------------------
// 2) General Settings
// ------------------------------------------------
var g_general = "🔱Universal Parameters🔱"
bool waitForBarConfirmation = input.bool(true, "Confirmation on Bar", group=g_general, tooltip="When enabled, signals will only trigger after the current bar is fully formed")
bool reversalMode = input.bool(false, "Invert Trend", group=g_general, tooltip="When enabled, strategy will look for trend reversals instead of trend continuations")

// ------------------------------------------------
// 3) Trade Type
// ------------------------------------------------
var group_trade_type = "❤️Direction Configuration❤️"
longTrades  = input.bool(true,  "Allow Long Positions", group=group_trade_type, inline="trade_type", tooltip="Enable/disable long trades. Useful if you're bearish and want to exclude long trades for this asset.")
shortTrades = input.bool(true,  "Allow Short Positions", group=group_trade_type, inline="trade_type", tooltip="Enable/disable short trades. Useful if you're bullish and want to exclude short trades for this asset.")

// ------------------------------------------------
// 4) Margin & Position Size
// ------------------------------------------------
var g_posSizing = "💪Margin & Positioning💪"
useFixedRiskPct = input.bool(false, "Always Use 1% Fixed Risk", group=g_posSizing, tooltip="Maintains exactly 1% account risk per trade regardless of leverage. This dynamic position sizer uses your current equity (not initial capital) to calculate risk, ensuring consistent risk exposure throughout your trading journey. With higher leverage, position size increases proportionally while the dollar risk remains fixed at 1% of your equity. For example, with a $100,000 account, 1% stop loss, and BTC at $40,000: at 1x leverage you'd trade 2.5 BTC, at 10x leverage 25 BTC, and at 67x leverage 167.5 BTC,  all risking exactly $1,000. The system prevents liquidation by ensuring your stop loss triggers first, and automatically adapts position size after wins and losses to maintain the fixed 1% risk allocation.")
useRawQty = input.bool(false, "Fixed Raw Contracts Position", group=g_posSizing, tooltip="Enable to use a fixed raw quantity for position sizing, bypassing dynamic calculations.")
rawPositionQty = input.float(1.0, "Raw Contracts Qty", minval=0.0001, step=0.0001, group=g_posSizing, tooltip="Set the fixed raw contracts quantity for position sizing when using fixed amounts.")
risk = input.float(10, "Risk Allocation (%)", minval=0.1, group=g_posSizing, tooltip="Set the percentage of your portfolio to risk per trade, determining position size.")
userLeverage = input.float(15, "Leverage Factor", minval=1, group=g_posSizing, tooltip="Set the leverage ratio to amplify position size, increasing both potential returns and risks.")

// ------------------------------------------------
// 5) Adaptive Volatility Sizing
// ------------------------------------------------
var g_position_risk = "🌋Adaptive Volatility Sizing🌋"
positionSizeType = input.string("Manual", "Position Sizing Style", options=["Manual","Dynamic Algo","Dynamic Algo 2","Risk Based"], group=g_position_risk, inline="psize", tooltip="Select position sizing method: Manual (fixed sizing), Dynamic Algo  (Uses ATR% vs. a 50-bar avg: if current ATR% is much higher than average, we go smaller (da1); if much lower, we go bigger (da3); otherwise da2.) Dynamic Algo 2 (Uses RSI & ROC: if RSI > 50 & ROC > 0, go near da3; if RSI < 50 & ROC < 0, go near da1; else da2.)")
daSource = input.string("ATR", "Volatility Source", options=["close","volume","MA5","MA25","MACD","ATR","ADX"], group=g_position_risk, inline="psizee", tooltip="Choose the data source for the dynamic position sizing algorithm: closing price, volume, moving averages, MACD, ATR, or ADX.")
da1 = input.float(0.5, "VFac#1", minval=0, step=0.1, group=g_position_risk, inline="da", tooltip="Set the position size multiplier for low volatility in the dynamic algo.")
da2 = input.float(1,   "VFac#2", minval=0, step=0.1, group=g_position_risk, inline="da", tooltip="Set the position size multiplier for moderate volatility in the dynamic algo.")
da3 = input.float(1.5, "VFac#3", minval=0, step=0.1, group=g_position_risk, inline="da", tooltip="Set the position size multiplier for high volatility in the dynamic algo.")

// ------------------------------------------------
// 6) Exit Protocols
// ------------------------------------------------
var g_exit = "🔥Exit Protocols🔥"
takeProfitType = input.string("R:R", "Take Profit Variation", options=["ATR","Fixed Percentage","R:R","Structure HH/LL","Structure High/Low"], group=g_exit, tooltip="Choose the take profit method: ATR for dynamic range-based TP, Fixed Percentage for a set TP percentage, R:R for risk-reward ratio, or Structure HH/LL/High/Low for price structure-based TP.")
stopLossType   = input.string("ATR", "Stop Loss Variation",  options=["None","Fixed Percent","ATR","HH/LL","Keltner","Bollinger Bands","Donchian Channel","EMA"], group=g_exit, tooltip="Select the stop loss method: None for no SL, Fixed Percent for a set percentage, ATR for dynamic range-based SL, or indicator-based options like HH/LL, Keltner, etc.")

// ------------------------------------------------
// 7) Layered Profit-Targets
// ------------------------------------------------
var g_multi_tp = "💰Layered Profit-Targets💰"
useMultiTP = input.bool(false, "Multiple TPs (X3)", group=g_multi_tp, tooltip="Enable multiple take-profit levels (TP1, TP2, TP3). Note: This works on percentages and may depend on your API connector. Be cautious, as it can skew backtesting results in TradingView.")
tp1Enabled = input.bool(false, "TP1 Active", group=g_multi_tp, inline="tp1", tooltip="Enable/disable the first take-profit level.")
tp1Percent = input.float(33.0, "% for TP1", minval=0.1, maxval=100, step=0.1, group=g_multi_tp, inline="tp1", tooltip="Set the percentage of the position to close at the first take-profit level.")
tp1Level = input.float(33.0, "Threshold TP1", minval=0.1, maxval=100, step=0.1, group=g_multi_tp, inline="tp1", tooltip="Set the profit percentage threshold to trigger the first take-profit.")
tp2Enabled = input.bool(false, "TP2 Active", group=g_multi_tp, inline="tp2", tooltip="Enable/disable the second take-profit level.")
tp2Percent = input.float(33.0, "% for TP2", minval=0.1, maxval=100, step=0.1, group=g_multi_tp, inline="tp2", tooltip="Set the percentage of the position to close at the second take-profit level.")
tp2Level = input.float(66.0, "Threshold TP2", minval=0.1, maxval=100, step=0.1, group=g_multi_tp, inline="tp2", tooltip="Set the profit percentage threshold to trigger the second take-profit.")
tp3Percent = input.float(100.0, "% for TP3", minval=0.1, maxval=100, step=0.1, group=g_multi_tp, inline="tp3", tooltip="Set the percentage of the position to close at the third take-profit level (closes remaining position).")
tp3Level = input.float(100.0, "Threshold TP3", minval=0.1, maxval=100, step=0.1, group=g_multi_tp, inline="tp3", tooltip="Set the profit percentage threshold to trigger the third take-profit.")

// ------------------------------------------------
// 8) Fixed Ratio Targets
// ------------------------------------------------
var g_fixed_percent = "😂Fixed Ratio Targets😂"
stopLossLongPercent   = input.float(1.0, "Stop Loss Long (%)",    minval=0.1, step=0.1, group=g_fixed_percent, tooltip="Set the fixed percentage for stop loss on long trades.")
takeProfitLongPercent = input.float(2.0, "Take Profit Long (%)",  minval=0.1, step=0.1, group=g_fixed_percent, tooltip="Set the fixed percentage for take profit on long trades.")
stopLossShortPercent  = input.float(1.0, "Stop Loss Short (%)",   minval=0.1, step=0.1, group=g_fixed_percent, tooltip="Set the fixed percentage for stop loss on short trades.")
takeProfitShortPercent= input.float(2.0, "Take Profit Short (%)", minval=0.1, step=0.1, group=g_fixed_percent, tooltip="Set the fixed percentage for take profit on short trades.")

// ------------------------------------------------
// 9) Swing High/Low Logic
// ------------------------------------------------
var g_hh_ll = "🪀Swing High/Low Logic🪀"
hhllLookback = input.int(20, "HH/LL Lookback", minval=1, group=g_hh_ll, tooltip="Set the lookback period in bars to calculate the highest high and lowest low for HH/LL exits.")

// ------------------------------------------------
// 10) Enhanced R:R Logic
// ------------------------------------------------
var g_r_r = "🙏Enhanced R:R Logic🙏"
rrRatioLong  = input.float(2, "Long R:R Ratio",  minval=0.1, step=0.1, group=g_r_r, tooltip="Set the risk-to-reward ratio for long trades, used with ATR and HH/LL for take profits.")
rrRatioShort = input.float(1.6, "Short R:R Ratio", minval=0.1, step=0.1, group=g_r_r, tooltip="Set the risk-to-reward ratio for short trades, used with ATR and HH/LL for take profits.")

// ------------------------------------------------
// 11) Structure-Based TP
// ------------------------------------------------
var g_structure = "🗿Structure-Based TP🗿"
leftBars  = input.int(9, "Left Bars to Check", minval=1, group=g_structure, tooltip="Set the number of bars to look left on the chart for calculating Structure HH/LL and High/Low take profits.")
rightBars = input.int(1, "Right Bars to Check", minval=1, group=g_structure, tooltip="Set the number of bars to look right on the chart for calculating Structure HH/LL and High/Low take profits.")

// ------------------------------------------------
// 12) ATR Protections
// ------------------------------------------------
var g_atr_stoploss = "🔮ATR Protections🔮"
atrLength = input.int(11, "Global ATR Length", minval=1, group=g_atr_stoploss, tooltip="Set the period length for calculating the Average True Range (ATR) used in stop-loss and take-profit calculations.")
globalAtrMultiplier = input.float(1.5, "Global ATR Multiplier", minval=0.1, step=0.1, group=g_atr_stoploss, tooltip="Set the multiplier to scale the ATR for both stop-loss and take-profit when custom settings are not used.")
atrSource = input.string("Source", "ATR Source", options=["Source","Swing High/Low"], group=g_atr_stoploss, tooltip="Choose the source for ATR calculation: 'Source' for standard ATR, or 'Swing High/Low' for swing-based ATR.")
atrSwingLookback = input.int(9, "ATR Swing Lookback", minval=1, group=g_atr_stoploss, tooltip="Set the lookback period for swing highs and lows when using 'Swing High/Low' as the ATR source.")

// Separate ATR settings for Stop Loss
useCustomAtrSL = input.bool(false, "Custom ATR for Stop Loss", group=g_atr_stoploss, tooltip="Enable to use separate ATR length and multiplier for Stop Loss calculations.")
atrLengthSL = input.int(14, "ATR Length (SL)", minval=1, group=g_atr_stoploss, tooltip="Set the period length for ATR used in stop-loss calculations. Only used if Custom ATR for SL is enabled.")
atrMultiplierForStoploss = input.float(2.5, "ATR Multiplier (SL)", minval=0.1, step=0.1, group=g_atr_stoploss, tooltip="Set the multiplier to scale the ATR for determining the stop-loss level. Only used if Custom ATR for SL is enabled.")

// Separate ATR settings for Take Profit
useCustomAtrTP = input.bool(false, "Custom ATR for Take Profit", group=g_atr_stoploss, tooltip="Enable to use separate ATR length and multiplier for Take Profit calculations.")
atrLengthTP = input.int(14, "ATR Length (TP)", minval=1, group=g_atr_stoploss, tooltip="Set the period length for ATR used in take-profit calculations. Only used if Custom ATR for TP is enabled.")
atrMultiplierForTakeProfit = input.float(3.0, "ATR Multiplier (TP)", minval=0.1, step=0.1, group=g_atr_stoploss, tooltip="Set the multiplier to scale the ATR for determining the take-profit level. Only used if Custom ATR for TP is enabled.")

// ------------------------------------------------
// 13) Supplementary Exit Indicators
// ------------------------------------------------
var g_iexit = "🥰Supplementary Exit Indicators🥰"
keltnerLength = input.int(20, "Keltner Length", minval=1, group=g_iexit, tooltip="Set the period length for the Keltner Channel used in stop-loss calculations.")
keltnerMultiplier = input.float(2.0, "Keltner Multiplier", minval=0.1, step=0.1, group=g_iexit, tooltip="Set the multiplier for the Keltner Channel to determine stop-loss levels.")
bollingerLength = input.int(20, "Bollinger Length", minval=1, group=g_iexit, tooltip="Set the period length for Bollinger Bands used in stop-loss calculations.")
bollingerStDev = input.float(2.0, "Bollinger StDev", minval=0.1, step=0.1, group=g_iexit, tooltip="Set the standard deviation multiplier for Bollinger Bands to determine stop-loss levels.")
donchianLength = input.int(20, "Donchian Channel Length", minval=1, group=g_iexit, tooltip="Set the period length for the Donchian Channel used in stop-loss calculations.")
ma1Period = input.int(10, "EMA Period", minval=1, group=g_iexit, tooltip="Set the custom period length for EMA used in stop-loss calculations.")

// ------------------------------------------------
// 14) Precision Adjustments
// ------------------------------------------------
var g_accuracy = "⚡Precision Adjustments⚡"
roundToDecimal = input.bool(true, "Round to Symbol Decimals", group=g_accuracy, tooltip="Enable rounding to the symbol's decimal points for improved accuracy with your exchange.")
manualDecimalPoints = input.int(1, "Manual Decimal Points", minval=1, group=g_accuracy, tooltip="Set the maximum number of decimal points for manual rounding, enhancing precision across exchanges.")
roundingMethod = input.string("Round", "Rounding Method", options=["Round","Ceil"], group=g_accuracy, tooltip="Choose the rounding method: 'Round' for standard rounding, or 'Ceil' for ceiling rounding.")

// ------------------------------------------------
// 15) Leverage Safeguards
// ------------------------------------------------
var g_leverage_risk = "🌋Leverage Safeguards🌋"
i_leverageBlock = input.bool(true, "Safety Against Liquidation", group=g_leverage_risk, tooltip="Prevent trades where the liquidation level is riskier than the stop loss, based on an estimate before trade execution.")
i_Maintenance = input.float(0.5, "Maintenance Margin Rate", minval=0.1, step=0.1, group=g_leverage_risk, tooltip="Set the maintenance margin rate for leverage calculations. Research your exchange's rate before using leverage algorithms.")

// ------------------------------------------------
// 16) Risk-Reward Filters
// ------------------------------------------------
var g_risk_management = "🛡️Risk-Reward Filters🛡️"
waitCandlesBetweenEntries = input.int(1, "Pause X Bars Between Entries", minval=0, group=g_risk_management, tooltip="Set the number of candles to wait between trades. Use 0 or below to disable.")
activateMinTP = input.bool(false, "Minimum Take Profit", group=g_risk_management, tooltip="Enable a minimum take-profit percentage to filter out unprofitable trades, especially with techniques like Fibonacci levels.")
minTPAction = input.string("Do not enter", "If TP Too Small", options=["Do not enter","Use Percentage Instead"], group=g_risk_management, tooltip="Decide what happens if the take profit is below the minimum: prevent entry or replace with the minimum percentage.")
minTPThreshold = input.float(1.0, "Minimal Acceptable TP %", minval=0.1, step=0.1, group=g_risk_management, tooltip="Set the minimum take-profit percentage threshold for trades.")
activateMaxSL = input.bool(true, "Max Stop Loss", group=g_risk_management, tooltip="Enable a maximum stop-loss percentage to limit trade risk.")
maxSLAction = input.string("Use Percentage Instead", "If SL Threshold Breaks", options=["Do not enter","Use Percentage Instead"], group=g_risk_management, tooltip="Decide what happens if the stop loss exceeds the maximum: prevent entry or replace with the maximum percentage.")
maxSLThreshold = input.float(3.4, "Max Acceptable SL %", minval=0.1, step=0.1, group=g_risk_management, tooltip="Set the maximum stop-loss percentage threshold to control trade risk.")

// ------------------------------------------------
// 17) Early Termination
// ------------------------------------------------
var g_early_exit = "⛵Early Termination⛵"
earlyExitProtection = input.bool(false, "Premature MA-Based Exit", group=g_early_exit, tooltip="Enable closing a position early if the price crosses a moving average, reducing potential losses or locking in profits.")
maProtectionType = input.string("EMA", "MA Protection Type", options=["EMA","HEMA","SMA","HMA","WMA","DEMA","VWMA","VWAP","T3"], group=g_early_exit, tooltip="Select the type of moving average for early exit protection.")
maProtectionLength = input.int(50, "Protection MA Length", minval=1, group=g_early_exit, tooltip="Set the period length for the moving average used in early exit protection.")
indicatorSourceProtection = input.string("close", "Protection MA Source", options=["open","high","low","close","hl2","hlc3","ohlc3","hlcc4"], group=g_early_exit, tooltip="Choose the price source for the early exit protection moving average.")

// ------------------------------------------------
// 18) Moving Average Configuration
// ------------------------------------------------
var g_ma_strategy = "⚓Moving Average Configuration⚓"
useMA = input.string("Off", "Use MA Strategy", options=["Off","Close over/under MA5","Strict Close over/under MA5","5 MA (Ordered)","3 MA (Ordered)","3 MA (Strict)","3 MA (Cross)"], group=g_ma_strategy, tooltip="Select the moving average strategy for trade confluence or filtering.")
inverseMA = input.bool(false, "Invert MA Logic", group=g_ma_strategy, tooltip="Enable to invert the moving average conditions, potentially reversing trade signals.")
boolmaLength1 = input.bool(false, "MA #1 Enabled", group=g_ma_strategy, inline="ma1", tooltip="Enable/disable the first moving average for confluence.")
maType1 = input.string("EMA", "MA #1 Type", options=["EMA","SMA","HMA","WMA","DEMA","T3"], group=g_ma_strategy, inline="ma1", tooltip="Choose the type of moving average for MA #1.")
maLength1 = input.int(9, "MA #1 Period", minval=1, group=g_ma_strategy, inline="ma1", tooltip="Set the period length for MA #1, ideally shorter than MA #2 to avoid conflicting signals.")
boolmaLength2 = input.bool(false, "MA #2 Enabled", group=g_ma_strategy, inline="ma2", tooltip="Enable/disable the second moving average for confluence.")
maType2 = input.string("EMA", "MA #2 Type", options=["EMA","SMA","HMA","WMA","DEMA","T3"], group=g_ma_strategy, inline="ma2", tooltip="Choose the type of moving average for MA #2.")
maLength2 = input.int(21, "MA #2 Period", minval=1, group=g_ma_strategy, inline="ma2", tooltip="Set the period length for MA #2, ideally longer than MA #1 to avoid conflicting signals.")
boolmaLength3 = input.bool(false, "MA #3 Enabled", group=g_ma_strategy, inline="ma3", tooltip="Enable/disable the third moving average for confluence.")
maType3 = input.string("EMA", "MA #3 Type", options=["EMA","SMA","HMA","WMA","DEMA","T3"], group=g_ma_strategy, inline="ma3", tooltip="Choose the type of moving average for MA #3.")
maLength3 = input.int(55, "MA #3 Period", minval=1, group=g_ma_strategy, inline="ma3", tooltip="Set the period length for MA #3, typically longer for confluence.")
boolmaLength4 = input.bool(false, "MA #4 Enabled", group=g_ma_strategy, inline="ma4", tooltip="Enable/disable the fourth moving average for confluence.")
maType4 = input.string("EMA", "MA #4 Type", options=["EMA","SMA","HMA","WMA","DEMA","T3"], group=g_ma_strategy, inline="ma4", tooltip="Choose the type of moving average for MA #4.")
maLength4 = input.int(100, "MA #4 Period", minval=1, group=g_ma_strategy, inline="ma4", tooltip="Set the period length for MA #4, typically longer for confluence.")
boolmaLength5 = input.bool(false, "MA #5 Enabled", group=g_ma_strategy, inline="ma5", tooltip="Enable/disable the fifth moving average for confluence.")
maType5 = input.string("EMA", "MA #5 Type", options=["EMA","SMA","HMA","WMA","DEMA","T3"], group=g_ma_strategy, inline="ma5", tooltip="Choose the type of moving average for MA #5.")
maLength5 = input.int(200, "MA #5 Period", minval=1, group=g_ma_strategy, inline="ma5", tooltip="Set the period length for MA #5, typically the longest for confluence.")
boolhmabar = input.bool(false, "Show HMA BAR", group=g_ma_strategy, inline="hma", tooltip="Enable/disable the Hull Moving Average (HMA) bar for visual confirmation.")
hmabar = input.int(100, "HMA Bar Length", minval=1, group=g_ma_strategy, inline="hma", tooltip="Set the period length for the Hull Moving Average bar.")

// ------------------------------------------------
// 19) Directional Trade Limit
// ------------------------------------------------
var g_max_trades = "🚫Directional Trade Limit🚫"
enableMaxTrades = input.bool(false, "Enforce Max Trades", group=g_max_trades, tooltip="Activate a limit on the maximum number of trades in one direction.")
maxTradesPerDirection = input.int(5, "Max Trades in One Direction", minval=1, group=g_max_trades, tooltip="Set the maximum number of consecutive trades allowed in one direction before pausing until a trade in the opposite direction occurs.")

// ------------------------------------------------
// 20) Range-Based Filter
// ------------------------------------------------
var g_range_filter = "📏Range-Based Filter📏"
useRangeFilter = input.bool(false, "Incorporate Range Filter", group=g_range_filter, tooltip="Enable the Range Filter to filter trades based on price volatility.")
rfPeriod = input.int(100, "Range Filter Period", minval=1, group=g_range_filter, tooltip="Set the period length for the Range Filter to assess volatility.")
rfMulti = input.float(1.2, "Range Filter Multiplier", minval=0.1, step=0.1, group=g_range_filter, tooltip="Set the multiplier for the Range Filter to adjust volatility thresholds.")

// ------------------------------------------------
// 21) Volume Flow Checker
// ------------------------------------------------
var g_volume_flow = "📈Volume Flow Checker📈"
enableVolumeFlow = input.bool(false, "Incorporate Volume Flow", group=g_volume_flow, tooltip="Enable the Volume Flow Index (VFI) as a trade filter for volume analysis.")
vfiLength = input.int(130, "VFI Length", minval=1, group=g_volume_flow, tooltip="Set the period length for the Volume Flow Index calculation.")
coef = input.float(0.2, "VFI Coefficient", minval=0.1, step=0.1, group=g_volume_flow, tooltip="Set the coefficient for the Volume Flow Index, adjusting sensitivity.")
maxVolCutoff = input.float(3, "Max Volume Cutoff", minval=0.1, step=0.1, group=g_volume_flow, tooltip="Set the maximum volume cutoff for the Volume Flow Index to filter extreme volumes.")

// ------------------------------------------------
// 22) ADX Momentum
// ------------------------------------------------
var g_adx_settings = "📈ADX Momentum📈"
enableADX = input.bool(false, "Incorporate ADX Momentum", group=g_adx_settings, tooltip="Enable the Average Directional Index (ADX) as a trade filter for trend strength.")
adxType = input.string("MasaNakamura", "ADX Calculation", options=["Normal","Stoch","MasaNakamura"], group=g_adx_settings, tooltip="Choose the ADX calculation method: Normal for standard, Stoch for stochastic, or MasaNakamura for a custom approach.")
adxLineType = input.string("Static", "ADX Line Type", options=["Static","MA","EMA","SMA","HMA","WMA","DEMA","VWMA","T3"], group=g_adx_settings, tooltip="Select the line type for ADX: static value or moving average types.")
adxSmoothing = input.int(14, "ADX Smoothing", minval=1, group=g_adx_settings, tooltip="Set the smoothing period for the ADX calculation.")
adxAboveLine = input.int(20, "ADX Threshold", minval=1, maxval=100, group=g_adx_settings, tooltip="Set the ADX threshold above which trades are considered strong.")
adxMALength = input.int(200, "ADX MA Length", minval=1, group=g_adx_settings, tooltip="Set the period length for the ADX moving average, if applicable.")
useDI = input.bool(true, "Enable DI for Direction", group=g_adx_settings, tooltip="Enable Directional Indicators (DI) for trend direction in ADX filtering.")
diLength = input.int(14, "DI Period", minval=1, group=g_adx_settings, tooltip="Set the period length for Directional Indicators in ADX.")
minStochLength = input.int(19, "ADX Min Stoch Length", minval=1, group=g_adx_settings, tooltip="Set the minimum stochastic length for ADX stochastic mode.")
maxStochLength = input.int(100, "ADX Max Stoch Smooth", minval=1, group=g_adx_settings, tooltip="Set the maximum stochastic length for smoothing in ADX stochastic mode.")
stochSmoothing = input.int(2, "ADX Stoch Smoothing", minval=1, group=g_adx_settings, tooltip="Set the smoothing period for the ADX stochastic calculation.")
inverseAdaptive = input.bool(false, "Inverse ADX Logic", group=g_adx_settings, tooltip="Enable to invert the ADX adaptive logic, potentially reversing signals.")
useRateOfChange = input.bool(false, "Apply Rate of Change", group=g_adx_settings, tooltip="Enable rate of change calculations for ADX, enhancing trend detection.")

// ------------------------------------------------
// 23) TDFI Confirmation
// ------------------------------------------------
var g_tdfi_settings = "📉TDFI Confirmation📉"
enableTDFI = input.bool(false, "Incorporate Volume Confirm TDFI", group=g_tdfi_settings, tooltip="Enable the Trend Direction Force Index (TDFI) for volume-based trade confirmation.")
tdfiVersion = input.string("v1", "TDFI Version", options=["v1","v2"], group=g_tdfi_settings, tooltip="Select the TDFI version: v1 for standard, v2 for advanced calculations.")
tdfiHigh = input.float(0.03, "TDFI Filter High", minval=-100, maxval=100, step=0.01, group=g_tdfi_settings, tooltip="Set the upper threshold for TDFI filtering.")
tdfiLow = input.float(-0.03, "TDFI Filter Low", minval=-100, maxval=100, step=0.01, group=g_tdfi_settings, tooltip="Set the lower threshold for TDFI filtering.")
mmaLengthV2 = input.int(13, "MMA Length (v2)", minval=1, group=g_tdfi_settings, tooltip="Set the moving average length for TDFI version 2.")
mmaModeV2 = input.string("ema", "MMA Mode (v2)", options=["ema","wma","swma","vwma","hull","tema"], group=g_tdfi_settings, tooltip="Select the moving average type for TDFI v2 calculations.")
smmaModeV2 = input.string("ema", "SMMA Mode (v2)", options=["ema","wma","swma","vwma","hull","tema"], group=g_tdfi_settings, tooltip="Select the smoothing moving average type for TDFI v2 calculations.")
nLengthV2 = input.int(3, "N-Length (v2)", minval=1, group=g_tdfi_settings, tooltip="Set the N-length for TDFI version 2 calculations.")

// ------------------------------------------------
// 24) Flat Market Filter
// ------------------------------------------------
var g_flat_market = "🛌Flat Market Filter🛌"
enableFlatMarket = input.bool(false, "Detect Flat Market", group=g_flat_market, tooltip="Enable the Flat Market filter to identify and avoid low-volatility periods.")
maTypeFlatMarket = input.string("EMA", "Flat Market MA Type", options=["Static","MA","EMA","SMA","HMA","WMA","DEMA","VWMA","T3"], group=g_flat_market, tooltip="Select the moving average type for Flat Market detection.")
maLengthFlatMarket = input.int(24, "Flat Market MA Length", minval=1, group=g_flat_market, tooltip="Set the period length for the Flat Market moving average.")
flatMarketAboveLine = input.int(1, "Flat Market Threshold", minval=1, maxval=100, group=g_flat_market, tooltip="Set the threshold above which the market is considered flat.")
useRateOfChangeFlat = input.bool(false, "Use Rate of Change for Flat", group=g_flat_market, tooltip="Enable rate of change calculations for Flat Market, enhancing volatility detection.")

// ------------------------------------------------
// 25) Hurst Exponent Filter
// ------------------------------------------------
var g_hurst_settings = "🌊Hurst Exponent Filter🌊"
enableHurst = input.bool(false, "Incorporate Hurst", group=g_hurst_settings, tooltip="Enable the Hurst Exponent for market trend analysis as a trade filter.")
hurstExpLength = input.int(64, "Hurst Length", minval=1, group=g_hurst_settings, tooltip="Set the period length for the Hurst Exponent calculation.")
hurstType = input.string("Trending Market", "Hurst Mode", options=["Trending Market","Consolidation","Random Walk"], group=g_hurst_settings, tooltip="Select the market condition for Hurst analysis: trending, consolidation, or random walk.")

// ------------------------------------------------
// 26) Bull-Bear Metric
// ------------------------------------------------
var g_bull_bear = "🐂Bull-Bear Metric🐻"
enableBullBear = input.bool(false, "Incorporate Bull-Bear Gauge", group=g_bull_bear, tooltip="Enable the Bull Bear Power indicator for trade filtering based on market strength.")
bbpLength = input.int(13, "Bull-Bear Period", minval=1, group=g_bull_bear, tooltip="Set the period length for the Bull Bear Power calculation.")

// ------------------------------------------------
// 27) VWAP/EMA Crossover
// ------------------------------------------------
var g_vwap_crossover = "📊VWAP/EMA Crossover📊"
useVWAPEMA = input.bool(false, "Incorporate VWAP/EMA Filter", group=g_vwap_crossover, tooltip="Enable the VWAP/EMA crossover as a trade filter.")
vwapSource = input.string("close", "VWAP Source", options=["open","high","low","close","hl2","hlc3","ohlc3","hlcc4"], group=g_vwap_crossover, tooltip="Select the price source for the VWAP calculation.")
vwap2Source = input.string("close", "VWAP2/EMA Source", options=["open","high","low","close","hl2","hlc3","ohlc3","hlcc4"], group=g_vwap_crossover, tooltip="Select the price source for the second VWAP or EMA in the crossover.")
vwapLength = input.int(5, "VWAP Length", minval=1, group=g_vwap_crossover, tooltip="Set the period length for the VWAP calculation.")

// ------------------------------------------------
// 27.5) Planetary Hours Filter
// ------------------------------------------------
var g_planetary = "🪐Planetary Hours Filter🪐"
usePlanetaryFilter = input.bool(false, "Use Planetary Hours Filter", group=g_planetary)
planetaryStrictness = input.float(1.0, "Planetary Strictness Multiplier", minval=0.1, maxval=2.0, step=0.1, group=g_planetary, tooltip="Higher values make the filter stricter")
longPlanet = input.string("Venus", "Long Trade Planet", options=["Sun", "Venus", "Mercury", "Moon", "Saturn", "Jupiter", "Mars"], group=g_planetary)
shortPlanet = input.string("Mars", "Short Trade Planet", options=["Sun", "Venus", "Mercury", "Moon", "Saturn", "Jupiter", "Mars"], group=g_planetary)
useForceExit = input.bool(true, "Use Planetary Force Exit", group=g_planetary)
forceExitLongPlanet = input.string("Mars", "Force Exit Long Planet", options=["Sun", "Venus", "Mercury", "Moon", "Saturn", "Jupiter", "Mars", "None"], group=g_planetary, tooltip="Select planet hour to force exit long positions")
forceExitShortPlanet = input.string("Venus", "Force Exit Short Planet", options=["Sun", "Venus", "Mercury", "Moon", "Saturn", "Jupiter", "Mars", "None"], group=g_planetary, tooltip="Select planet hour to force exit short positions")
forceExitWaitBars = input.int(3, "Force Exit Wait Bars", minval=0, group=g_planetary, tooltip="Number of bars to wait before allowing force exit")

// ------------------------------------------------
// 39) Custom Indicator Comparisons
// ------------------------------------------------
// Settings for External Comparison #1
comparisonGroup1 = "🤖======== Settings - Comparison #1 ========🤖"
ActivateExternalComparison1 = input.bool(false, ' 🧠 Activate External Comparison 1 🧠 ', group=comparisonGroup1)
Source1_1 = input.source(close, title="First Indicator", group=comparisonGroup1)
Source2_1 = input.source(close, title="Second Indicator", group=comparisonGroup1)
fixedLevelLong1 = input.float(0, title="🟢 Fixed Level Long", group=comparisonGroup1)
fixedLevelShort1 = input.float(0, title="🔴 Fixed Level Short", group=comparisonGroup1)
LongHeading1 = input.bool(false, '======== LONG SETTINGS ========', group=comparisonGroup1)
longSource1 = input.source(close, title="Long Source 1", inline="Long Condition", group=comparisonGroup1)
longOperator1 = input.string(">", title="Long Operator", options=[">", "<", ">=", "<=", "==", "!=", "crossover", "crossunder", "isrising", "isfalling"], inline="Long Condition", group=comparisonGroup1)
longTarget1 = input.string("First Indicator", title="Long Source 2", options=["First Indicator", "Second Indicator", "Fixed Level Long"], inline="Long Condition", group=comparisonGroup1)
ShortHeading1 = input.bool(false, '======== SHORT SETTINGS ========', group=comparisonGroup1)
shortSource1 = input.source(close, title="Short Source 1", inline="Short Condition", group=comparisonGroup1)
shortOperator1 = input.string("<", title="Short Operator", options=[">", "<", ">=", "<=", "==", "!=", "crossover", "crossunder", "isrising", "isfalling"], inline="Short Condition", group=comparisonGroup1)
shortTarget1 = input.string("First Indicator", title="Short Source 2", options=["First Indicator", "Second Indicator", "Fixed Level Short"], inline="Short Condition", group=comparisonGroup1)

// Settings for External Comparison #2
comparisonGroup2 = "🤖======== Settings - Comparison #2 ========🤖"
ActivateExternalComparison2 = input.bool(false, ' 🧠 Activate External Comparison 2 🧠 ', group=comparisonGroup2)
Source1_2 = input.source(close, title="First Indicator", group=comparisonGroup2)
Source2_2 = input.source(close, title="Second Indicator", group=comparisonGroup2)
fixedLevelLong2 = input.float(0, title="🟢 Fixed Level Long", group=comparisonGroup2)
fixedLevelShort2 = input.float(0, title="🔴 Fixed Level Short", group=comparisonGroup2)
LongHeading2 = input.bool(false, '======== LONG SETTINGS ========', group=comparisonGroup2)
longSource2 = input.source(close, title="Long Source 1", inline="Long Condition", group=comparisonGroup2)
longOperator2 = input.string(">", title="Long Operator", options=[">", "<", ">=", "<=", "==", "!=", "crossover", "crossunder", "isrising", "isfalling"], inline="Long Condition", group=comparisonGroup2)
longTarget2 = input.string("First Indicator", title="Long Source 2", options=["First Indicator", "Second Indicator", "Fixed Level Long"], inline="Long Condition", group=comparisonGroup2)
ShortHeading2 = input.bool(false, '======== SHORT SETTINGS ========', group=comparisonGroup2)
shortSource2 = input.source(close, title="Short Source 1", inline="Short Condition", group=comparisonGroup2)
shortOperator2 = input.string("<", title="Short Operator", options=[">", "<", ">=", "<=", "==", "!=", "crossover", "crossunder", "isrising", "isfalling"], inline="Short Condition", group=comparisonGroup2)
shortTarget2 = input.string("First Indicator", title="Short Source 2", options=["First Indicator", "Second Indicator", "Fixed Level Short"], inline="Short Condition", group=comparisonGroup2)

// ------------------------------------------------
// 28) Time & Session Management
// ------------------------------------------------
var g_time_date = "🕒Time & Session Management🕒"
timezone = input.string("GMT", "Timezone", options=["GMT-12","GMT-11","GMT-10","GMT-9","GMT-8","GMT-7","CST","GMT-6","GMT-5","GMT-4","GMT-3","GMT-2","GMT-1","GMT","GMT+1","GMT+2","GMT+3","GMT+4","GMT+5","GMT+6","GMT+7","GMT+8","GMT+9","GMT+10","GMT+11","GMT+12"], group=g_time_date, tooltip="Select the timezone for your strategy, affecting session and event timing.")
useSessions = input.bool(true, "Use Sessions & Weekdays", group=g_time_date, tooltip="Enable session and weekday filters for your strategy. Required for Week Days, Sessions, or Filters to function.")

// ------------------------------------------------
// 29) Date Constraints
// ------------------------------------------------
var g_date = "🛰️Date Constraints🛰️"
DateFilter = input.bool(false, "Date Range Filtering", group=g_date, tooltip="Enable a date range filter to limit backtesting or live trading to specific dates.")
i_startTime = input.time(timestamp("01 Jan 2019 13:30 +0000"), "Start Time", group=g_date, tooltip="Set the starting date and time for backtesting or live trading simulation.")
i_endTime = input.time(timestamp("30 Dec 2021 23:30 +0000"), "End Time", group=g_date, tooltip="Set the ending date and time for backtesting or live trading simulation.")

// ------------------------------------------------
// 30) Intraday Sessions
// ------------------------------------------------
var g_session_filters = "⏰Intraday Sessions⏰"
allowSession1 = input.bool(false, "Allow Custom Session #1", group=g_session_filters, tooltip="Enable trading only during Custom Session 1.")
allowSession2 = input.bool(false, "Allow Custom Session #2", group=g_session_filters, tooltip="Enable trading only during Custom Session 2.")
trade24_7 = input.bool(true, "Trade Constantly", group=g_session_filters, tooltip="Enable 24/7 trading, typically for whales trading all sessions.")
endSessionClose = input.bool(false, "Close Positions End of Session", group=g_session_filters, tooltip="Enable closing all trades at the end of a session.")
session1Start = input.string("08:00", "Session #1 Start", options=["00:00","00:15","00:30","00:45","01:00","01:15","01:30","01:45","02:00","02:15","02:30","02:45","03:00","03:15","03:30","03:45","04:00","04:15","04:30","04:45","05:00","05:15","05:30","05:45","06:00","06:15","06:30","06:45","07:00","07:15","07:30","07:45","08:00","08:15","08:30","08:45","09:00","09:15","09:30","09:45","10:00","10:15","10:30","10:45","11:00","11:15","11:30","11:45","12:00","12:15","12:30","12:45","13:00","13:15","13:30","13:45","14:00","14:15","14:30","14:45","15:00","15:15","15:30","15:45","16:00","16:15","16:30","16:45","17:00","17:15","17:30","17:45","18:00","18:15","18:30","18:45","19:00","19:15","19:30","19:45","20:00","20:15","20:30","20:45","21:00","21:15","21:30","21:45","22:00","22:15","22:30","22:45","23:00","23:15","23:30","23:45"], group=g_session_filters, inline="session1", tooltip="Set the start time for Custom Session 1 in 15-minute increments.")
session1End = input.string("13:30", "Session #1 End", options=["00:00","00:15","00:30","00:45","01:00","01:15","01:30","01:45","02:00","02:15","02:30","02:45","03:00","03:15","03:30","03:45","04:00","04:15","04:30","04:45","05:00","05:15","05:30","05:45","06:00","06:15","06:30","06:45","07:00","07:15","07:30","07:45","08:00","08:15","08:30","08:45","09:00","09:15","09:30","09:45","10:00","10:15","10:30","10:45","11:00","11:15","11:30","11:45","12:00","12:15","12:30","12:45","13:00","13:15","13:30","13:45","14:00","14:15","14:30","14:45","15:00","15:15","15:30","15:45","16:00","16:15","16:30","16:45","17:00","17:15","17:30","17:45","18:00","18:15","18:30","18:45","19:00","19:15","19:30","19:45","20:00","20:15","20:30","20:45","21:00","21:15","21:30","21:45","22:00","22:15","22:30","22:45","23:00","23:15","23:30","23:45"], group=g_session_filters, inline="session1", tooltip="Set the end time for Custom Session 1 in 15-minute increments. In Winter (when London = GMT):8:00 am. till 4:30 pm. GMT. In Summer (when London = BST, i.e., GMT+1):7:00 am. till 3:30 pm. GMT")
session2Start = input.string("14:30", "Session #2 Start", options=["00:00","00:15","00:30","00:45","01:00","01:15","01:30","01:45","02:00","02:15","02:30","02:45","03:00","03:15","03:30","03:45","04:00","04:15","04:30","04:45","05:00","05:15","05:30","05:45","06:00","06:15","06:30","06:45","07:00","07:15","07:30","07:45","08:00","08:15","08:30","08:45","09:00","09:15","09:30","09:45","10:00","10:15","10:30","10:45","11:00","11:15","11:30","11:45","12:00","12:15","12:30","12:45","13:00","13:15","13:30","13:45","14:00","14:15","14:30","14:45","15:00","15:15","15:30","15:45","16:00","16:15","16:30","16:45","17:00","17:15","17:30","17:45","18:00","18:15","18:30","18:45","19:00","19:15","19:30","19:45","20:00","20:15","20:30","20:45","21:00","21:15","21:30","21:45","22:00","22:15","22:30","22:45","23:00","23:15","23:30","23:45"], group=g_session_filters, inline="session2", tooltip="Set the start time for Custom Session 2 in 15-minute increments.")
session2End = input.string("20:30", "Session #2 End", options=["00:00","00:15","00:30","00:45","01:00","01:15","01:30","01:45","02:00","02:15","02:30","02:45","03:00","03:15","03:30","03:45","04:00","04:15","04:30","04:45","05:00","05:15","05:30","05:45","06:00","06:15","06:30","06:45","07:00","07:15","07:30","07:45","08:00","08:15","08:30","08:45","09:00","09:15","09:30","09:45","10:00","10:15","10:30","10:45","11:00","11:15","11:30","11:45","12:00","12:15","12:30","12:45","13:00","13:15","13:30","13:45","14:00","14:15","14:30","14:45","15:00","15:15","15:30","15:45","16:00","16:15","16:30","16:45","17:00","17:15","17:30","17:45","18:00","18:15","18:30","18:45","19:00","19:15","19:30","19:45","20:00","20:15","20:30","20:45","21:00","21:15","21:30","21:45","22:00","22:15","22:30","22:45","23:00","23:15","23:30","23:45"], group=g_session_filters, inline="session2", tooltip="Set the end time for Custom Session 2 in 15-minute increments. In Winter (Eastern Standard Time = UTC−5):2:30 pm. till 9:00 pm. GMT. In Summer (Eastern Daylight Time = UTC−4):1:30 pm. till 8:00 pm. GMT")

// ------------------------------------------------
// 31) Allowed Trading Days
// ------------------------------------------------
var g_weekdays = "🧭Allowed Trading Days🧭"
monday = input.bool(true, "Mon", group=g_weekdays, inline="weekdays", tooltip="Allow trades on Monday.")
tuesday = input.bool(true, "Tue", group=g_weekdays, inline="weekdays", tooltip="Allow trades on Tuesday.")
wednesday = input.bool(true, "Wed", group=g_weekdays, inline="weekdays", tooltip="Allow trades on Wednesday.")
thursday = input.bool(true, "Thu", group=g_weekdays, inline="weekdays", tooltip="Allow trades on Thursday.")
friday = input.bool(true, "Fri", group=g_weekdays, inline="weekdays", tooltip="Allow trades on Friday.")
saturday = input.bool(true, "Sat", group=g_weekdays, inline="weekdays", tooltip="Allow trades on Saturday.")
sunday = input.bool(true, "Sun", group=g_weekdays, inline="weekdays", tooltip="Allow trades on these days.")

// ------------------------------------------------
// 32) Realtime Trading Filter
// ------------------------------------------------
var g_live_trade = "🚀Realtime Trading Filter🚀"
LiveTradeFilter = input.bool(false, "Enable Real Time Filter", group=g_live_trade, tooltip="Enable a filter to limit real time trading to start from a specific date, ensuring real-time trade execution aligns with your strategy.")
i_liveStartTime = input.time(timestamp("25 Feb 2025 00:00 +0000"), "Real Time Starts", group=g_live_trade, tooltip="Set the starting date and time for live trading to begin sending real-time alerts.")

// ------------------------------------------------
// 33) Minimalist Bot Mode
// ------------------------------------------------
var g_minimalist_bot = "🤖Minimalist Bot Mode🤖"
useMinimalistBot = input.bool(false, "Use Minimalist Bot", group=g_minimalist_bot, tooltip="Enable a minimalistic bot mode for basic alerts, useful for debugging or basic trading setups.")
exchangeFormat = input.string("Crypto Exchange", "Exchange Format", options=["MT5", "Crypto Exchange"], group=g_minimalist_bot, tooltip="Select the format for Minimalist Bot JSON messages: MT5 for MetaTrader or Crypto Exchange for platforms like Bybit/Binance.")
useSafetyTP = input.bool(false, "Safety Take-Profit", group=g_minimalist_bot, tooltip="Enable a safety take-profit level to send to the exchange, ensuring minimal profit targets.")
useSafetySL = input.bool(false, "Safety Stop-Loss", group=g_minimalist_bot, tooltip="Enable a safety stop-loss level to send to the exchange, ensuring minimal risk thresholds.")
apiKey = input.string("****", "API Key", group=g_minimalist_bot, tooltip="Your API key for the trading platform.")
secretKey = input.string("****", "Secret Key (Crypto Only)", group=g_minimalist_bot, tooltip="Your secret key for crypto exchanges.")
accountNumber = input.string("mt5 account", "Account Number (MT5 Only)", group=g_minimalist_bot, tooltip="Your account number for MT5.")
emailId = input.string("xxxxxx@gmail.com", "Email ID", group=g_minimalist_bot, tooltip="Your email address for account identification.")
magicNumber = input.string("01", "Magic Number (MT5 Only)", group=g_minimalist_bot, tooltip="Magic number for MT5 order identification.")
telegramChannelID = input.string("", "Telegram Debugging ID (Crypto Only)", group=g_minimalist_bot, tooltip="Enter your Telegram channel ID for alert debugging and notifications, enhancing monitoring.")

// ------------------------------------------------
// 34) Global Alert Settings
// ------------------------------------------------
var g_alerts_global = "🔔Global Alert Settings🔔"
alertFrequency = input.string("Once per bar", "Alert Frequency", options=["Once per bar","Once per close","All"], group=g_alerts_global, tooltip="Set how often alerts are triggered:once per bar, once per bar close, or for every condition change.")
useImmediateAlerts = input.bool(true, "Immediate Alert Trigger", group=g_alerts_global, tooltip="Enable alerts to trigger instantly when conditions are met, improving real-time trade execution.")
alertMode = input.string("Order fills only", "Alert Mode", options=["Order fills and alert() function calls","Order fills only","alert() function calls only"], group=g_alerts_global, tooltip="Control which events generate alerts: both order fills and alert() calls, only order fills, or only alert() function calls.")

// ------------------------------------------------
// 35) API Connection Settings
// ------------------------------------------------
var g_api_connection = "🔌API Connection Settings🔌"
useAPIConnection = input.bool(false, "Enable API Connectivity", group=g_api_connection, tooltip="Enable to format alerts specifically for third-party API connectors like a Bybit bot.")
exchangeType = input.string("Bybit", "Exchange Type", options=["Bybit", "Binance", "FTX", "Custom"], group=g_api_connection, tooltip="Select your target exchange to generate appropriate API-formatted alerts.")
apiTestnet = input.bool(false, "Use Testnet/Paper Trading", group=g_api_connection, tooltip="Enable to generate alerts for testnet/paper trading environments instead of live trading.")
marginMode = input.string("Cross", "Margin Mode", options=["Cross", "Isolated"], group=g_api_connection, tooltip="Select the margin mode to use when placing orders via API.")
entryOrderType = input.string("Market", "Entry Order Type", options=["Market", "Limit"], group=g_api_connection, tooltip="Type of order to use for entries: Market orders execute immediately at current price, Limit orders specify a price.")
exitOrderType = input.string("Market", "Exit Order Type", options=["Market", "Limit"], group=g_api_connection, tooltip="Type of order to use for exits: Market orders execute immediately at current price, Limit orders specify a price.")
orderTimeout = input.int(60, "Order Timeout (seconds)", minval=1, group=g_api_connection, tooltip="Cancel limit orders if not filled within this timeframe.")

// ------------------------------------------------
// 36) Detailed Alert Messages
// ------------------------------------------------
var g_alert_messages = "🔔Detailed Alert Messages🔔"
i_alert_txt_entry_long = input.text_area("Available Placeholders for Dynamic Alerts:\n#pair# - Trading symbol\n#price# - Entry price\n#qty# - Position size\n#TP# - Take profit price\n#SL# - Stop loss price\n#lev# - Leverage used\n#risk# - Risk percentage\n#riskUSD# - Dollar risk amount\n#RR# - Risk-reward ratio\n#TPdist#, #SLdist# - TP/SL % distance\n#time# - Current date/time\n#pos# - Current position size\n#equity# - Account balance\n\nAPI Placeholders for Trading Bots:\n#testnet# - 0/1 for real/test\n#marginmode# - 0=Cross, 1=Isolated", "Long Entry Alert", group=g_alert_messages, tooltip="Custom message for long entry alerts")
i_alert_txt_entry_short = input.text_area("Available Placeholders for Dynamic Alerts:\n#pair# - Trading symbol\n#price# - Entry price\n#qty# - Position size\n#TP# - Take profit price\n#SL# - Stop loss price\n#lev# - Leverage used\n#risk# - Risk percentage\n#riskUSD# - Dollar risk amount\n#RR# - Risk-reward ratio\n#TPdist#, #SLdist# - TP/SL % distance\n#time# - Current date/time\n#pos# - Current position size\n#equity# - Account balance\n\nAPI Placeholders for Trading Bots:\n#testnet# - 0/1 for real/test\n#marginmode# - 0=Cross, 1=Isolated", "Short Entry Alert", group=g_alert_messages, tooltip="Custom message for short entry alerts")
i_alert_txt_exit_long = input.text_area("Available Placeholders for Dynamic Alerts:\n#pair# - Trading symbol\n#price# - Entry price\n#qty# - Position size\n#TP# - Take profit price\n#SL# - Stop loss price\n#lev# - Leverage used\n#risk# - Risk percentage\n#riskUSD# - Dollar risk amount\n#RR# - Risk-reward ratio\n#TPdist#, #SLdist# - TP/SL % distance\n#time# - Current date/time\n#pos# - Current position size\n#equity# - Account balance\n\nAPI Placeholders for Trading Bots:\n#testnet# - 0/1 for real/test\n#marginmode# - 0=Cross, 1=Isolated", "Long Exit Alert", group=g_alert_messages, tooltip="Custom message for long exit alerts")
i_alert_txt_exit_short = input.text_area("Available Placeholders for Dynamic Alerts:\n#pair# - Trading symbol\n#price# - Entry price\n#qty# - Position size\n#TP# - Take profit price\n#SL# - Stop loss price\n#lev# - Leverage used\n#risk# - Risk percentage\n#riskUSD# - Dollar risk amount\n#RR# - Risk-reward ratio\n#TPdist#, #SLdist# - TP/SL % distance\n#time# - Current date/time\n#pos# - Current position size\n#equity# - Account balance\n\nAPI Placeholders for Trading Bots:\n#testnet# - 0/1 for real/test\n#marginmode# - 0=Cross, 1=Isolated", "Short Exit Alert", group=g_alert_messages, tooltip="Custom message for short exit alerts")

// ------------------------------------------------
// 37) Multi-Target Alert Templates
// ------------------------------------------------
var g_alerts_multi_tp = "🔔Multi-Target Alert Templates🔔"
i_alert_txt_tp1_long = input.text_area("Available Placeholders for Dynamic Alerts:\n#pair# - Trading symbol\n#price# - Entry price\n#qty# - Position size\n#TP# - Take profit price\n#SL# - Stop loss price\n#lev# - Leverage used\n#risk# - Risk percentage\n#riskUSD# - Dollar risk amount\n#RR# - Risk-reward ratio\n#TPdist#, #SLdist# - TP/SL % distance\n#time# - Current date/time\n#pos# - Current position size\n#equity# - Account balance\n\nAPI Placeholders for Trading Bots:\n#testnet# - 0/1 for real/test\n#marginmode# - 0=Cross, 1=Isolated", "Long TP1 Alert (33%)", group=g_alerts_multi_tp, tooltip="Custom message for first take profit on long positions")
i_alert_txt_tp2_long = input.text_area("Available Placeholders for Dynamic Alerts:\n#pair# - Trading symbol\n#price# - Entry price\n#qty# - Position size\n#TP# - Take profit price\n#SL# - Stop loss price\n#lev# - Leverage used\n#risk# - Risk percentage\n#riskUSD# - Dollar risk amount\n#RR# - Risk-reward ratio\n#TPdist#, #SLdist# - TP/SL % distance\n#time# - Current date/time\n#pos# - Current position size\n#equity# - Account balance\n\nAPI Placeholders for Trading Bots:\n#testnet# - 0/1 for real/test\n#marginmode# - 0=Cross, 1=Isolated", "Long TP2 Alert (66%)", group=g_alerts_multi_tp, tooltip="Custom message for second take profit on long positions")
i_alert_txt_tp3_long = input.text_area("Available Placeholders for Dynamic Alerts:\n#pair# - Trading symbol\n#price# - Entry price\n#qty# - Position size\n#TP# - Take profit price\n#SL# - Stop loss price\n#lev# - Leverage used\n#risk# - Risk percentage\n#riskUSD# - Dollar risk amount\n#RR# - Risk-reward ratio\n#TPdist#, #SLdist# - TP/SL % distance\n#time# - Current date/time\n#pos# - Current position size\n#equity# - Account balance\n\nAPI Placeholders for Trading Bots:\n#testnet# - 0/1 for real/test\n#marginmode# - 0=Cross, 1=Isolated", "Long TP3 Alert (All)", group=g_alerts_multi_tp, tooltip="Custom message for third take profit on long positions")
i_alert_txt_tp1_short = input.text_area("Available Placeholders for Dynamic Alerts:\n#pair# - Trading symbol\n#price# - Entry price\n#qty# - Position size\n#TP# - Take profit price\n#SL# - Stop loss price\n#lev# - Leverage used\n#risk# - Risk percentage\n#riskUSD# - Dollar risk amount\n#RR# - Risk-reward ratio\n#TPdist#, #SLdist# - TP/SL % distance\n#time# - Current date/time\n#pos# - Current position size\n#equity# - Account balance\n\nAPI Placeholders for Trading Bots:\n#testnet# - 0/1 for real/test\n#marginmode# - 0=Cross, 1=Isolated", "Short TP1 Alert (33%)", group=g_alerts_multi_tp, tooltip="Custom message for first take profit on short positions")
i_alert_txt_tp2_short = input.text_area("Available Placeholders for Dynamic Alerts:\n#pair# - Trading symbol\n#price# - Entry price\n#qty# - Position size\n#TP# - Take profit price\n#SL# - Stop loss price\n#lev# - Leverage used\n#risk# - Risk percentage\n#riskUSD# - Dollar risk amount\n#RR# - Risk-reward ratio\n#TPdist#, #SLdist# - TP/SL % distance\n#time# - Current date/time\n#pos# - Current position size\n#equity# - Account balance\n\nAPI Placeholders for Trading Bots:\n#testnet# - 0/1 for real/test\n#marginmode# - 0=Cross, 1=Isolated", "Short TP2 Alert (66%)", group=g_alerts_multi_tp, tooltip="Custom message for second take profit on short positions")
i_alert_txt_tp3_short = input.text_area("Available Placeholders for Dynamic Alerts:\n#pair# - Trading symbol\n#price# - Entry price\n#qty# - Position size\n#TP# - Take profit price\n#SL# - Stop loss price\n#lev# - Leverage used\n#risk# - Risk percentage\n#riskUSD# - Dollar risk amount\n#RR# - Risk-reward ratio\n#TPdist#, #SLdist# - TP/SL % distance\n#time# - Current date/time\n#pos# - Current position size\n#equity# - Account balance\n\nAPI Placeholders for Trading Bots:\n#testnet# - 0/1 for real/test\n#marginmode# - 0=Cross, 1=Isolated", "Short TP3 Alert (All)", group=g_alerts_multi_tp, tooltip="Custom message for third take profit on short positions")

// ------------------------------------------------
// 38) Monthly Performance Overview
// ------------------------------------------------
var g_dashboard      = "📊Monthly Performance Overview📊"
var profit_loss_table= "Statistics Table Inputs"
showTable            = input.bool(false, "Display Monthly Returns Table", group=profit_loss_table, tooltip="Enable to show a performance table summarizing monthly returns in TradingView.")
prec                 = input.int(2, "Table Precision", group=profit_loss_table, tooltip="Set the decimal precision for the monthly returns table.")

// ----------------------
// Math functions 
// ----------------------
// Get source price based on selection
getSourcePrice(srcString) => srcString == "open" ? open : srcString == "high" ? high : srcString == "low" ? low : srcString == "close" ? close : srcString == "hl2" ? hl2 : srcString == "hlc3" ? hlc3 : srcString == "ohlc4" ? ohlc4 : srcString == "hlcc4" ? (high + low + close + close) / 4 : close

// Efficiently round to precision 
round_to_precision(v, p) => math.round(v * math.pow(10, p)) / math.pow(10, p)

// Helper function for rounding quantity
f_round_qty(qty) => roundToDecimal ? (roundingMethod == "Ceil" ? math.ceil(qty * math.pow(10, manualDecimalPoints)) / math.pow(10, manualDecimalPoints) : round_to_precision(math.round(qty * math.pow(10, manualDecimalPoints)) / math.pow(10, manualDecimalPoints), manualDecimalPoints)) : qty

// Calculate leverage with safety
_calculateLeverage(_leverage, _value, _shortSell) => _shortSell ? _value * _leverage / (_leverage - 1 + i_Maintenance / 100 * _leverage) : _leverage * _value / (_leverage + 1 - i_Maintenance / 100 * _leverage)

// ----------------------
// Session Filter Implementation with Timezone Support
// ----------------------
// Session Management Functions - Optimized for v6
adjustHour(int inputHour) =>
    // Parse timezone string to get offset hours
    tzOffset = timezone == "GMT" ? 0 : timezone == "CST" ? -6 : str.contains(timezone, "+") ? int(str.tonumber(str.substring(timezone, 4))) : str.contains(timezone, "-") ? -int(str.tonumber(str.substring(timezone, 4))) : 0    // Adjust hour and handle day boundaries
    int adjustedHour = (inputHour + tzOffset) % 24
    adjustedHour < 0 ? adjustedHour + 24 : adjustedHour

isInTradingSession() =>
    if not useSessions
        true
    else
        // Current bar's time components
        int curHour = hour(time)
        int curMinute = minute(time)
        int adjHour = adjustHour(curHour)
        
        // Parse session times
        // Session 1
        s1StartHour = int(str.tonumber(str.substring(session1Start, 0, 2)))
        s1StartMinute = int(str.tonumber(str.substring(session1Start, 3, 5)))
        s1EndHour = int(str.tonumber(str.substring(session1End, 0, 2)))
        s1EndMinute = int(str.tonumber(str.substring(session1End, 3, 5)))
        
        // Session 2
        s2StartHour = int(str.tonumber(str.substring(session2Start, 0, 2)))
        s2StartMinute = int(str.tonumber(str.substring(session2Start, 3, 5)))
        s2EndHour = int(str.tonumber(str.substring(session2End, 0, 2)))
        s2EndMinute = int(str.tonumber(str.substring(session2End, 3, 5)))
        
        // Convert to minute-of-day for comparison
        int currentMinOfDay = adjHour * 60 + curMinute
        int s1StartMinOfDay = s1StartHour * 60 + s1StartMinute
        int s1EndMinOfDay = s1EndHour * 60 + s1EndMinute
        int s2StartMinOfDay = s2StartHour * 60 + s2StartMinute
        int s2EndMinOfDay = s2EndHour * 60 + s2EndMinute
        
        // Check session ranges, handling overnight sessions correctly
        bool inSession1 = s1StartMinOfDay < s1EndMinOfDay ? (currentMinOfDay >= s1StartMinOfDay and currentMinOfDay < s1EndMinOfDay) : (currentMinOfDay >= s1StartMinOfDay or currentMinOfDay < s1EndMinOfDay)
        
        bool inSession2 = s2StartMinOfDay < s2EndMinOfDay ? (currentMinOfDay >= s2StartMinOfDay and currentMinOfDay < s2EndMinOfDay) : (currentMinOfDay >= s2StartMinOfDay or currentMinOfDay < s2EndMinOfDay)
        
        // Apply trading session rules
        trade24_7 or (allowSession1 and not allowSession2 and inSession1) or (allowSession2 and not allowSession1 and inSession2) or (allowSession1 and allowSession2 and (inSession1 or inSession2))
		
// Check for end of session
isEndOfSession() =>
    if not useSessions or not endSessionClose
        false
    else
        // Current bar's time components
        int curHour = hour(time)
        int curMinute = minute(time)
        int adjHour = adjustHour(curHour)
        
        // Parse end times
        s1EndHour = int(str.tonumber(str.substring(session1End, 0, 2)))
        s1EndMinute = int(str.tonumber(str.substring(session1End, 3, 5)))
        s2EndHour = int(str.tonumber(str.substring(session2End, 0, 2)))
        s2EndMinute = int(str.tonumber(str.substring(session2End, 3, 5)))
        
        // Check if we're at either session end time
        (allowSession1 and adjHour == s1EndHour and curMinute == s1EndMinute) or (allowSession2 and adjHour == s2EndHour and curMinute == s2EndMinute)

TradeDayIsAllowed() =>
    if not useSessions
        true
    else
        day = dayofweek(time)
        day == 2 ? monday : day == 3 ? tuesday : day == 4 ? wednesday : day == 5 ? thursday : day == 6 ? friday : day == 7 ? saturday : day == 1 ? sunday : true                     

TradeDateIsAllowed() =>
    not(useSessions and DateFilter) or (time >= i_startTime and time <= i_endTime)

LiveTradeIsAllowed() =>
    not(useSessions and LiveTradeFilter) or time >= i_liveStartTime

// ----------------------
// Multi Take Profit Implementation - Section 1
// ----------------------
var bool stopLossDisabled = false  // Initialize the flag
var int lastEntryCandle = 0
var float entrySL = na
var float entryTP = na
var float entryPrice = 0.0
var bool tradeActive = false
var bool isLong = false
var bool tp1Reached = false
var bool tp2Reached = false
var bool tp3Reached = false
var float tp1Price = 0.0
var float tp2Price = 0.0
var float tp3Price = 0.0
var int longTradesCount = 0
var int shortTradesCount = 0
var int lastTradeDirection = 0
var int lastTrendilioExitBar = 0
var int lastEntryBarIndex = 0
var int lastExitBarIndex = 0
var bool waitForNewBarEntry = false
var bool waitForNewBarExit = false
var bool inPosition = false
var string currentPosition = "flat" // "flat", "long", or "short"
bool validLongEntry = true
bool validShortEntry = true
bool validEntry = true

// Trendilio stabilization
var int trendilioSignalCooldownPeriod = 3  // Number of bars to wait before new signals
var int trendilioSignalCooldownCounter = 0
var bool lastSignalWasLong = false
var bool lastSignalWasShort = false
var float avpchSmoothed = 0.0

// Declare variables for all the ATR calculations we might need
var float standardATR = 0.0
var float swingATR = 0.0
var float standardATR_SL = 0.0
var float swingATR_SL = 0.0
var float standardATR_TP = 0.0
var float swingATR_TP = 0.0

// Calculate all possible ATR values directly at the global scope
// For global ATR
standardATR := ta.atr(atrLength)
float swingHigh = ta.highest(high, atrSwingLookback)
float swingLow = ta.lowest(low, atrSwingLookback)
float swingRange = math.abs(swingHigh - swingLow)
swingATR := ta.sma(swingRange, atrLength)

// For SL-specific ATR (if enabled)
if useCustomAtrSL
    standardATR_SL := ta.atr(atrLengthSL)
    float swingHigh_SL = ta.highest(high, atrSwingLookback)
    float swingLow_SL = ta.lowest(low, atrSwingLookback)
    float swingRange_SL = math.abs(swingHigh_SL - swingLow_SL)
    swingATR_SL := ta.sma(swingRange_SL, atrLengthSL)
else
    standardATR_SL := standardATR
    swingATR_SL := swingATR

// For TP-specific ATR (if enabled)
if useCustomAtrTP
    standardATR_TP := ta.atr(atrLengthTP)
    float swingHigh_TP = ta.highest(high, atrSwingLookback)
    float swingLow_TP = ta.lowest(low, atrSwingLookback)
    float swingRange_TP = math.abs(swingHigh_TP - swingLow_TP)
    swingATR_TP := ta.sma(swingRange_TP, atrLengthTP)
else
    standardATR_TP := standardATR
    swingATR_TP := swingATR

// Then simply select the right values based on the source type
var float atrGlobal = 0.0
var float atrSL = 0.0
var float atrTP = 0.0

atrGlobal := atrSource == "Source" ? standardATR : swingATR
atrSL := useCustomAtrSL ? (atrSource == "Source" ? standardATR_SL : swingATR_SL) : atrGlobal
atrTP := useCustomAtrTP ? (atrSource == "Source" ? standardATR_TP : swingATR_TP) : atrGlobal

var float highestVal = 0.0
var float lowestVal = 0.0
var float ma1Val = 0.0
var float keltnerVal = 0.0
var float bollingerStdevVal = 0.0

// Update pre-calculated values on each bar
highestVal := ta.highest(high, hhllLookback)
lowestVal := ta.lowest(low, hhllLookback)
ma1Val := ta.ema(close, ma1Period)
keltnerVal := ta.atr(keltnerLength)
bollingerStdevVal := ta.stdev(close, bollingerLength)

// Function to calculate stop loss level
calculateStopLoss(bool isLongPosition, float curPrice) =>
    float stopLevel = na
    
    if isLongPosition
        if stopLossType == "None"
            stopLevel := curPrice * 0.01  // Very small value, effectively disabled
        else if stopLossType == "ATR"
            stopLevel := curPrice - atrSL * (useCustomAtrSL ? atrMultiplierForStoploss : globalAtrMultiplier)
        else if stopLossType == "Fixed Percent"
            stopLevel := curPrice * (1 - stopLossLongPercent / 100)
        else if stopLossType == "HH/LL"
            stopLevel := lowestVal
        else if stopLossType == "Keltner"
            stopLevel := curPrice - keltnerMultiplier * keltnerVal
        else if stopLossType == "Bollinger Bands"
            stopLevel := curPrice - bollingerStDev * bollingerStdevVal
        else if stopLossType == "Donchian Channel"
            stopLevel := lowestVal
        else if stopLossType == "EMA"
            stopLevel := ma1Val
        else
            stopLevel := curPrice * (1 - stopLossLongPercent / 100)
    else
        if stopLossType == "None"
            stopLevel := curPrice * 100  // Very large value, effectively disabled
        else if stopLossType == "ATR"
            stopLevel := curPrice + atrSL * (useCustomAtrSL ? atrMultiplierForStoploss : globalAtrMultiplier)
        else if stopLossType == "Fixed Percent"
            stopLevel := curPrice * (1 + stopLossShortPercent / 100)
        else if stopLossType == "HH/LL"
            stopLevel := highestVal
        else if stopLossType == "Keltner"
            stopLevel := curPrice + keltnerMultiplier * keltnerVal
        else if stopLossType == "Bollinger Bands"
            stopLevel := curPrice + bollingerStDev * bollingerStdevVal
        else if stopLossType == "Donchian Channel"
            stopLevel := highestVal
        else if stopLossType == "EMA"
            stopLevel := ma1Val
        else
            stopLevel := curPrice * (1 + stopLossShortPercent / 100)
    
    stopLevel
	
// Function to calculate take profit level
calculateTakeProfit(bool isLongPosition, float curPrice, float stopLevel) =>
    float takeLevel = na
    
    if isLongPosition
        if takeProfitType == "Fixed Percentage"
            takeLevel := curPrice * (1 + takeProfitLongPercent / 100)
        else if takeProfitType == "ATR"
            takeLevel := curPrice + atrTP * (useCustomAtrTP ? atrMultiplierForTakeProfit : globalAtrMultiplier)
        else if takeProfitType == "R:R"
            if stopLossType == "None" or stopLevel == curPrice * 0.01
                // When stop loss is disabled but using R:R, fall back to fixed percentage
                takeLevel := curPrice * (1 + takeProfitLongPercent / 100)
            else
                // Normal R:R calculation when stop loss is active
                float localRisk = curPrice - stopLevel
                takeLevel := curPrice + localRisk * rrRatioLong
        else if takeProfitType == "Structure HH/LL" or takeProfitType == "Structure High/Low"
            takeLevel := highestVal
        else
            takeLevel := curPrice * (1 + takeProfitLongPercent / 100)
    else
        if takeProfitType == "Fixed Percentage"
            takeLevel := curPrice * (1 - takeProfitShortPercent / 100)
        else if takeProfitType == "ATR"
            takeLevel := curPrice - atrTP * (useCustomAtrTP ? atrMultiplierForTakeProfit : globalAtrMultiplier)
        else if takeProfitType == "R:R"
            if stopLossType == "None" or stopLevel == curPrice * 100
                // When stop loss is disabled but using R:R, fall back to fixed percentage
                takeLevel := curPrice * (1 - takeProfitShortPercent / 100)
            else
                // Normal R:R calculation when stop loss is active
                float localRisk = stopLevel - curPrice
                takeLevel := curPrice - localRisk * rrRatioShort
        else if takeProfitType == "Structure HH/LL" or takeProfitType == "Structure High/Low"
            takeLevel := lowestVal
        else
            takeLevel := curPrice * (1 - takeProfitShortPercent / 100)
    
    takeLevel

// Function to calculate multi-TP levels
calculateMultiTpLevels(bool isLongPosition, float entryPrice, float stopLevel) =>
    float tp1 = 0.0
    float tp2 = 0.0
    float tp3 = 0.0
    
    // Get base TP level from the take profit calculation
    float baseTP = calculateTakeProfit(isLongPosition, entryPrice, stopLevel)
    
    if isLongPosition
        // Long position TP calculations
        if takeProfitType == "Fixed Percentage"
            tp1 := entryPrice * (1 + (takeProfitLongPercent * tp1Level / 100) / 100)
            tp2 := entryPrice * (1 + (takeProfitLongPercent * tp2Level / 100) / 100)
            tp3 := entryPrice * (1 + (takeProfitLongPercent * tp3Level / 100) / 100)
        else
            // For all other types, scale based on base TP
            float distance = math.abs(baseTP - entryPrice)
            tp1 := entryPrice + distance * (tp1Level / 100)
            tp2 := entryPrice + distance * (tp2Level / 100)
            tp3 := entryPrice + distance * (tp3Level / 100)
    else
        // Short position TP calculations
        if takeProfitType == "Fixed Percentage"
            tp1 := entryPrice * (1 - (takeProfitShortPercent * tp1Level / 100) / 100)
            tp2 := entryPrice * (1 - (takeProfitShortPercent * tp2Level / 100) / 100)
            tp3 := entryPrice * (1 - (takeProfitShortPercent * tp3Level / 100) / 100)
        else
            // For all other types, scale based on base TP
            float distance = math.abs(entryPrice - baseTP)
            tp1 := entryPrice - distance * (tp1Level / 100)
            tp2 := entryPrice - distance * (tp2Level / 100)
            tp3 := entryPrice - distance * (tp3Level / 100)
    
    [tp1, tp2, tp3]

// Pre-calculate stop-loss and take-profit levels for current bar
var float slLong = calculateStopLoss(true, close)
var float tpLong = calculateTakeProfit(true, close, slLong)
var float slShort = calculateStopLoss(false, close)
var float tpShort = calculateTakeProfit(false, close, slShort)

// Update levels on each bar
slLong := calculateStopLoss(true, close)
tpLong := calculateTakeProfit(true, close, slLong)
slShort := calculateStopLoss(false, close)
tpShort := calculateTakeProfit(false, close, slShort)

// Pre-calculate multi-TP levels
var float tp1Long = 0.0
var float tp2Long = 0.0
var float tp3Long = 0.0
var float tp1Short = 0.0
var float tp2Short = 0.0
var float tp3Short = 0.0

// Calculate multi-TP levels only if needed
if useMultiTP
    [tp1L, tp2L, tp3L] = calculateMultiTpLevels(true, close, slLong)
    tp1Long := tp1L
    tp2Long := tp2L
    tp3Long := tp3L
    
    [tp1S, tp2S, tp3S] = calculateMultiTpLevels(false, close, slShort)
    tp1Short := tp1S
    tp2Short := tp2S
    tp3Short := tp3S

// Function to approximate ADX
adx_approximation(int length) =>
    float tr = ta.tr(true)
    float atr = ta.ema(tr, length)
    float up = high - high[1]
    float down = low[1] - low
    float plusDM = up > down and up > 0 ? up : 0
    float minusDM = down > up and down > 0 ? down : 0
    float smoothedPlusDM = ta.ema(plusDM, length)
    float smoothedMinusDM = ta.ema(minusDM, length)
    float plusDI = 100 * smoothedPlusDM / atr
    float minusDI = 100 * smoothedMinusDM / atr
    float dx = math.abs(plusDI - minusDI) / (plusDI + minusDI) * 100
    float adx = ta.ema(dx, length)
    adx

// Define the risk source based on user selection for Dynamic Algo
_get_risk_source() =>
    float result = close  // Default value
    if daSource == "close"
        result := close
    else if daSource == "volume"
        result := volume
    else if daSource == "MA5"
        result := ta.sma(close, 5)
    else if daSource == "MA25"
        result := ta.sma(close, 25)
    else if daSource == "MACD"
        result := ta.sma(close, 5) - ta.sma(close, 25)
    else if daSource == "ATR"
        result := ta.atr(14)
    else if daSource == "ADX"
        result := adx_approximation(14)
    result

// Calculate risk zones for Dynamic Algo
var float riskSource = _get_risk_source()
var float risk_highest = ta.highest(riskSource, 100)
var float risk_lowest = ta.lowest(riskSource, 100)

// Update them on each bar
riskSource := _get_risk_source()
risk_highest := ta.highest(riskSource, 100)
risk_lowest := ta.lowest(riskSource, 100)

var float risk_third = (risk_highest - risk_lowest) / 3
var float risk_zone_1 = risk_lowest + risk_third
var float risk_zone_2 = risk_highest - risk_third

// Update these on each bar too
risk_third := (risk_highest - risk_lowest) / 3
risk_zone_1 := risk_lowest + risk_third
risk_zone_2 := risk_highest - risk_third

// ------------------------------------------------
// Script 1: Optimized Multi-Factor Dynamic Position Sizing
// ------------------------------------------------
get_da_multiplier() =>
    // Detect key market conditions
    float ma_fast = ta.ema(close, 10)
    float ma_slow = ta.ema(close, 50)
    float ma_trend = ta.ema(close, 200)
    
    // Determine market regime
    bool bull_market = ma_fast > ma_slow and ma_slow > ma_trend
    bool bear_market = ma_fast < ma_slow and ma_slow < ma_trend
    bool transition_market = (ma_fast > ma_slow and ma_slow < ma_trend) or 
                             (ma_fast < ma_slow and ma_slow > ma_trend)
    
    // Calculate volatility metrics
    float atr = ta.atr(14)
    float atr_pct = atr / close * 100
    float historic_atr_pct = ta.sma(atr / close * 100, 50)
    
    // Calculate drawdown from recent high
    float recent_high = ta.highest(high, 20)
    float drawdown_pct = (recent_high - close) / recent_high * 100
    
    float result = da2  // Default to moderate position size
    
    // Adjust position size based on market regime and drawdown
    if bull_market
        if drawdown_pct < 2  // Near highs - full position
            result := da3
        else if drawdown_pct < 5  // Small pullback - slightly reduced
            result := da2 * 1.2
        else  // Significant pullback in bull market - be cautious
            result := da2
    else if bear_market
        if drawdown_pct > 8  // Deep pullback in bear market - very conservative
            result := da1 * 0.9
        else  // Normal conditions in bear market - conservative
            result := da1
    else  // Transition market
        if atr_pct > historic_atr_pct * 1.5  // High volatility in transition - very conservative
            result := da1 * 0.8
        else  // Normal volatility in transition - moderate conservative
            result := da1 * 1.1
    
    // Apply trend-biased volatility scaling
    float vol_scale = math.max(0.7, math.min(1.3, historic_atr_pct / atr_pct))
    result := result * vol_scale
    
    // Apply constraints for safety
    result := math.max(da1 * 0.7, math.min(result, da3 * 1.1))

    result

get_da2_multiplier() =>
    // Trend analysis with multiple indicators
    float ma_20 = ta.sma(close, 20)
    float ma_50 = ta.sma(close, 50)
    float ma_200 = ta.sma(close, 200)
    
    // Advanced momentum analysis
    float roc_short = ta.roc(close, 5)
    float roc_medium = ta.roc(close, 15)
    float roc_long = ta.roc(close, 30)
    
    // RSI for overbought/oversold detection
    float rsi = ta.rsi(close, 14)
    bool overbought = rsi > 70
    bool oversold = rsi < 30
    
    // Calculate composite momentum
    float momentum_composite = (roc_short * 0.5) + (roc_medium * 0.3) + (roc_long * 0.2)
    
    // Calculate momentum strength (absolute value)
    float momentum_strength = math.abs(momentum_composite)
    
    // Determine market trend
    bool uptrend = ma_20 > ma_50 and ma_50 > ma_200
    bool downtrend = ma_20 < ma_50 and ma_50 < ma_200
    bool sideways = not uptrend and not downtrend
    
    // Base position based on trend direction and momentum direction
    float result = da2  // Default moderate position
    
    if uptrend and momentum_composite > 0
        // Aligned uptrend with positive momentum
        if momentum_strength > 2.0
            result := da3  // Maximum size in strong, aligned uptrend
        else
            result := da2 * 1.4  // Larger than moderate in normal aligned uptrend
    else if uptrend and momentum_composite <= 0
        // Uptrend with negative momentum (potential reversal)
        result := da2 * 0.8  // Reduced position in conflicting signals
    else if downtrend and momentum_composite < 0
        // Aligned downtrend with negative momentum
        if momentum_strength > 2.0
            result := da1  // Minimum size in strong, aligned downtrend
        else
            result := da1 * 1.3  // Slightly larger than minimum in normal aligned downtrend
    else if downtrend and momentum_composite >= 0
        // Downtrend with positive momentum (potential reversal)
        result := da1 * 1.5  // Increased from minimum in conflicting signals
    else if sideways
        // Sideways market
        if momentum_strength > 1.5
            result := da2 * 1.1  // Slightly increased in strong momentum sideways
        else
            result := da2 * 0.9  // Slightly decreased in weak momentum sideways
    
    // Apply overbought/oversold adjustments
    if overbought and uptrend
        result := result * 0.9  // Reduce size in overbought conditions during uptrend
    else if oversold and downtrend
        result := result * 1.1  // Increase size in oversold conditions during downtrend
    
    // Smoothing for stability
    float prev_result = nz(result[1], result)
    result := result * 0.75 + prev_result * 0.25
    
    // Safety constraints
    result := math.max(da1 * 0.7, math.min(result, da3 * 1.1))
    
    result

// Position Sizing with Leverage for Fixed 1% Risk with Liquidation Protection
var float positionSize = na
var float accountRisk = 0.0
var float fixedRiskValue = 0.0

// Calculate risk amounts based on CURRENT equity, not initial capital
accountRisk := strategy.equity * (risk / 100)
fixedRiskValue := strategy.equity * 0.01  // Always 1% of CURRENT portfolio

// Initialize leverage values - needed for other parts of the script
var float firstLeverageLongAverage = _calculateLeverage(userLeverage, close, false)
var float firstLeverageShortAverage = _calculateLeverage(userLeverage, close, true)

// Update leverage values on each bar
firstLeverageLongAverage := _calculateLeverage(userLeverage, close, false)
firstLeverageShortAverage := _calculateLeverage(userLeverage, close, true)

// Calculate position size based on selected method
if not useRawQty
    // Calculate the stop loss distance for risk-based sizing
    float longStopDistance = math.abs(close - slLong)
    float shortStopDistance = math.abs(slShort - close)
    
    // Use the appropriate stop distance based on trade direction
    float riskDistance = (longStopDistance + shortStopDistance) / 2
    
    // Calculate the percentage stop loss distance
    float stopLossPercent = riskDistance / close
    
    // Calculate the maximum safe leverage based on stop loss and maintenance margin
    // Using the formula: maxLeverage = 1 / (stopLossPercent + i_Maintenance / 100)
    float maxSafeLeverage = stopLossPercent > 0 ? 1 / (stopLossPercent + i_Maintenance / 100) : 100.0
    
    // Add a safety buffer (10%) and cap at 100x leverage as an absolute maximum
    float maxAllowedLeverage = math.min(maxSafeLeverage * 0.9, 100.0)
    
    // Use the lesser of user-selected leverage or maximum safe leverage
    float effectiveLeverage = math.min(userLeverage, maxAllowedLeverage)
    
    if positionSizeType == "Manual"
        if useFixedRiskPct
            if riskDistance > 0
                
                // Calculate position size by dividing risk amount by adjusted stop loss
                float adjustedStopPercent = stopLossPercent / effectiveLeverage
                positionSize := fixedRiskValue / (close * adjustedStopPercent)
                
                // Check for liquidation risk - ensure stop loss comes before liquidation
                float liquidationPrice = isLong ? close * (1 - (1 / effectiveLeverage)) : close * (1 + (1 / effectiveLeverage))
                bool stopBeforeLiquidation = isLong ? slLong > liquidationPrice : slShort < liquidationPrice
                
                if not stopBeforeLiquidation
                    // If stop might not trigger before liquidation, limit the position size
                    float safetyRatio = 0.9  // 90% of max to provide buffer
                    float maxSafePosition = (strategy.equity / close) * maxAllowedLeverage * safetyRatio
                    positionSize := math.min(positionSize, maxSafePosition)
            else
                // Fallback with assumed 1% stop loss
                float assumedStopLossPercent = 0.01
                float adjustedAssumedStop = assumedStopLossPercent / effectiveLeverage
                positionSize := fixedRiskValue / (close * adjustedAssumedStop)
        else
            // For non-fixed risk calculations
            positionSize := (strategy.equity * (risk / 100) * userLeverage) / close
    
    else if positionSizeType == "Dynamic Algo"
        float daMultiplier = get_da_multiplier()
        if daMultiplier == 0
            positionSize := 0
        else
            if useFixedRiskPct
                if riskDistance > 0
                    // Calculate position size with leverage adjustment
                    float adjustedStopPercent = stopLossPercent / effectiveLeverage
                    positionSize := fixedRiskValue / (close * adjustedStopPercent) * daMultiplier
                    
                    // Check for liquidation risk
                    float liquidationPrice = isLong ? close * (1 - (1 / effectiveLeverage)) : close * (1 + (1 / effectiveLeverage))
                    bool stopBeforeLiquidation = isLong ? slLong > liquidationPrice : slShort < liquidationPrice
                    
                    if not stopBeforeLiquidation
                        float safetyRatio = 0.9
                        float maxSafePosition = (strategy.equity / close) * maxAllowedLeverage * safetyRatio * daMultiplier
                        positionSize := math.min(positionSize, maxSafePosition)
                else
                    // Fallback with assumed 1% stop loss
                    float assumedStopLossPercent = 0.01
                    float adjustedAssumedStop = assumedStopLossPercent / effectiveLeverage
                    positionSize := fixedRiskValue / (close * adjustedAssumedStop) * daMultiplier
            else
                // For non-fixed risk calculations
                positionSize := (strategy.equity * (risk / 100) * userLeverage * daMultiplier) / close
    
    else if positionSizeType == "Dynamic Algo 2"
        float daMultiplier = get_da2_multiplier()
        if daMultiplier == 0
            positionSize := 0
        else
            if useFixedRiskPct
                if riskDistance > 0
                    // Calculate position size with leverage adjustment
                    float adjustedStopPercent = stopLossPercent / effectiveLeverage
                    positionSize := fixedRiskValue / (close * adjustedStopPercent) * daMultiplier
                    
                    // Check for liquidation risk
                    float liquidationPrice = isLong ? close * (1 - (1 / effectiveLeverage)) : close * (1 + (1 / effectiveLeverage))
                    bool stopBeforeLiquidation = isLong ? slLong > liquidationPrice : slShort < liquidationPrice
                    
                    if not stopBeforeLiquidation
                        float safetyRatio = 0.9
                        float maxSafePosition = (strategy.equity / close) * maxAllowedLeverage * safetyRatio * daMultiplier
                        positionSize := math.min(positionSize, maxSafePosition)
                else
                    // Fallback with assumed 1% stop loss
                    float assumedStopLossPercent = 0.01
                    float adjustedAssumedStop = assumedStopLossPercent / effectiveLeverage
                    positionSize := fixedRiskValue / (close * adjustedAssumedStop) * daMultiplier
            else
                // For non-fixed risk calculations
                positionSize := (strategy.equity * (risk / 100) * userLeverage * daMultiplier) / close
    
    else if positionSizeType == "Risk Based"
        if useFixedRiskPct
            if riskDistance > 0
                // Calculate position size with leverage adjustment
                float adjustedStopPercent = stopLossPercent / effectiveLeverage
                positionSize := fixedRiskValue / (close * adjustedStopPercent)
                
                // Check for liquidation risk
                float liquidationPrice = isLong ? close * (1 - (1 / effectiveLeverage)) : close * (1 + (1 / effectiveLeverage))
                bool stopBeforeLiquidation = isLong ? slLong > liquidationPrice : slShort < liquidationPrice
                
                if not stopBeforeLiquidation
                    float safetyRatio = 0.9
                    float maxSafePosition = (strategy.equity / close) * maxAllowedLeverage * safetyRatio
                    positionSize := math.min(positionSize, maxSafePosition)
            else
                // Fallback with assumed 1% stop loss
                float assumedStopLossPercent = 0.01
                float adjustedAssumedStop = assumedStopLossPercent / effectiveLeverage
                positionSize := fixedRiskValue / (close * adjustedAssumedStop)
        else
            // For non-fixed risk calculations
            positionSize := (strategy.equity * (risk / 100) * userLeverage) / close
else
    positionSize := rawPositionQty * userLeverage
    
// Round the position size for accuracy
var float roundedQty = f_round_qty(positionSize)
roundedQty := positionSize == 0 ? 0 : math.max(f_round_qty(positionSize), 0.01)

// Pre-calculate all MA types for each length at root level
// For MA #1
var float ema_ma1 = na
var float sma_ma1 = na
var float hma_ma1 = na
var float wma_ma1 = na
var float dema_ma1_e1 = na
var float dema_ma1_e2 = na
var float dema_ma1 = na
var float t3_ma1_e1 = na
var float t3_ma1_e2 = na
var float t3_ma1_e3 = na
var float t3_ma1_e4 = na
var float t3_ma1_e5 = na
var float t3_ma1_e6 = na
var float t3_ma1 = na

// For MA #2
var float ema_ma2 = na
var float sma_ma2 = na
var float hma_ma2 = na
var float wma_ma2 = na
var float dema_ma2_e1 = na
var float dema_ma2_e2 = na
var float dema_ma2 = na
var float t3_ma2_e1 = na
var float t3_ma2_e2 = na
var float t3_ma2_e3 = na
var float t3_ma2_e4 = na
var float t3_ma2_e5 = na
var float t3_ma2_e6 = na
var float t3_ma2 = na

// For MA #3
var float ema_ma3 = na
var float sma_ma3 = na
var float hma_ma3 = na
var float wma_ma3 = na
var float dema_ma3_e1 = na
var float dema_ma3_e2 = na
var float dema_ma3 = na
var float t3_ma3_e1 = na
var float t3_ma3_e2 = na
var float t3_ma3_e3 = na
var float t3_ma3_e4 = na
var float t3_ma3_e5 = na
var float t3_ma3_e6 = na
var float t3_ma3 = na

// For MA #4
var float ema_ma4 = na
var float sma_ma4 = na
var float hma_ma4 = na
var float wma_ma4 = na
var float dema_ma4_e1 = na
var float dema_ma4_e2 = na
var float dema_ma4 = na
var float t3_ma4_e1 = na
var float t3_ma4_e2 = na
var float t3_ma4_e3 = na
var float t3_ma4_e4 = na
var float t3_ma4_e5 = na
var float t3_ma4_e6 = na
var float t3_ma4 = na

// For MA #5
var float ema_ma5 = na
var float sma_ma5 = na
var float hma_ma5 = na
var float wma_ma5 = na
var float dema_ma5_e1 = na
var float dema_ma5_e2 = na
var float dema_ma5 = na
var float t3_ma5_e1 = na
var float t3_ma5_e2 = na
var float t3_ma5_e3 = na
var float t3_ma5_e4 = na
var float t3_ma5_e5 = na
var float t3_ma5_e6 = na
var float t3_ma5 = na

// For HMA bar
var float hma = na   // Changed from hma_bar to hma to match original code
var color hmacolor = na

// Update MA values on each bar
// Calculate all possible MA types for MA #1
ema_ma1 := ta.ema(close, maLength1)
sma_ma1 := ta.sma(close, maLength1)
hma_ma1 := ta.hma(close, maLength1)
wma_ma1 := ta.wma(close, maLength1)
dema_ma1_e1 := ta.ema(close, maLength1)
dema_ma1_e2 := ta.ema(dema_ma1_e1, maLength1)
dema_ma1 := 2 * dema_ma1_e1 - dema_ma1_e2

// T3 calculation for MA #1
float vFactor_ma = 0.7
t3_ma1_e1 := ta.ema(close, maLength1)
t3_ma1_e2 := ta.ema(t3_ma1_e1, maLength1)
t3_ma1_e3 := ta.ema(t3_ma1_e2, maLength1)
t3_ma1_e4 := ta.ema(t3_ma1_e3, maLength1)
t3_ma1_e5 := ta.ema(t3_ma1_e4, maLength1)
t3_ma1_e6 := ta.ema(t3_ma1_e5, maLength1)
float c1_ma = -vFactor_ma * vFactor_ma * vFactor_ma
float c2_ma = 3 * vFactor_ma * vFactor_ma + 3 * vFactor_ma * vFactor_ma * vFactor_ma
float c3_ma = -6 * vFactor_ma * vFactor_ma - 3 * vFactor_ma - 3 * vFactor_ma * vFactor_ma * vFactor_ma
float c4_ma = 1 + 3 * vFactor_ma + vFactor_ma * vFactor_ma + 3 * vFactor_ma * vFactor_ma
t3_ma1 := c1_ma * t3_ma1_e6 + c2_ma * t3_ma1_e5 + c3_ma * t3_ma1_e4 + c4_ma * t3_ma1_e3

// Calculate all possible MA types for MA #2
ema_ma2 := ta.ema(close, maLength2)
sma_ma2 := ta.sma(close, maLength2)
hma_ma2 := ta.hma(close, maLength2)
wma_ma2 := ta.wma(close, maLength2)
dema_ma2_e1 := ta.ema(close, maLength2)
dema_ma2_e2 := ta.ema(dema_ma2_e1, maLength2)
dema_ma2 := 2 * dema_ma2_e1 - dema_ma2_e2

// T3 calculation for MA #2
t3_ma2_e1 := ta.ema(close, maLength2)
t3_ma2_e2 := ta.ema(t3_ma2_e1, maLength2)
t3_ma2_e3 := ta.ema(t3_ma2_e2, maLength2)
t3_ma2_e4 := ta.ema(t3_ma2_e3, maLength2)
t3_ma2_e5 := ta.ema(t3_ma2_e4, maLength2)
t3_ma2_e6 := ta.ema(t3_ma2_e5, maLength2)
t3_ma2 := c1_ma * t3_ma2_e6 + c2_ma * t3_ma2_e5 + c3_ma * t3_ma2_e4 + c4_ma * t3_ma2_e3

// Calculate all possible MA types for MA #3
ema_ma3 := ta.ema(close, maLength3)
sma_ma3 := ta.sma(close, maLength3)
hma_ma3 := ta.hma(close, maLength3)
wma_ma3 := ta.wma(close, maLength3)
dema_ma3_e1 := ta.ema(close, maLength3)
dema_ma3_e2 := ta.ema(dema_ma3_e1, maLength3)
dema_ma3 := 2 * dema_ma3_e1 - dema_ma3_e2

// T3 calculation for MA #3
t3_ma3_e1 := ta.ema(close, maLength3)
t3_ma3_e2 := ta.ema(t3_ma3_e1, maLength3)
t3_ma3_e3 := ta.ema(t3_ma3_e2, maLength3)
t3_ma3_e4 := ta.ema(t3_ma3_e3, maLength3)
t3_ma3_e5 := ta.ema(t3_ma3_e4, maLength3)
t3_ma3_e6 := ta.ema(t3_ma3_e5, maLength3)
t3_ma3 := c1_ma * t3_ma3_e6 + c2_ma * t3_ma3_e5 + c3_ma * t3_ma3_e4 + c4_ma * t3_ma3_e3

// Calculate all possible MA types for MA #4
ema_ma4 := ta.ema(close, maLength4)
sma_ma4 := ta.sma(close, maLength4)
hma_ma4 := ta.hma(close, maLength4)
wma_ma4 := ta.wma(close, maLength4)
dema_ma4_e1 := ta.ema(close, maLength4)
dema_ma4_e2 := ta.ema(dema_ma4_e1, maLength4)
dema_ma4 := 2 * dema_ma4_e1 - dema_ma4_e2

// T3 calculation for MA #4
t3_ma4_e1 := ta.ema(close, maLength4)
t3_ma4_e2 := ta.ema(t3_ma4_e1, maLength4)
t3_ma4_e3 := ta.ema(t3_ma4_e2, maLength4)
t3_ma4_e4 := ta.ema(t3_ma4_e3, maLength4)
t3_ma4_e5 := ta.ema(t3_ma4_e4, maLength4)
t3_ma4_e6 := ta.ema(t3_ma4_e5, maLength4)
t3_ma4 := c1_ma * t3_ma4_e6 + c2_ma * t3_ma4_e5 + c3_ma * t3_ma4_e4 + c4_ma * t3_ma4_e3

// Calculate all possible MA types for MA #5
ema_ma5 := ta.ema(close, maLength5)
sma_ma5 := ta.sma(close, maLength5)
hma_ma5 := ta.hma(close, maLength5)
wma_ma5 := ta.wma(close, maLength5)
dema_ma5_e1 := ta.ema(close, maLength5)
dema_ma5_e2 := ta.ema(dema_ma5_e1, maLength5)
dema_ma5 := 2 * dema_ma5_e1 - dema_ma5_e2

// T3 calculation for MA #5
t3_ma5_e1 := ta.ema(close, maLength5)
t3_ma5_e2 := ta.ema(t3_ma5_e1, maLength5)
t3_ma5_e3 := ta.ema(t3_ma5_e2, maLength5)
t3_ma5_e4 := ta.ema(t3_ma5_e3, maLength5)
t3_ma5_e5 := ta.ema(t3_ma5_e4, maLength5)
t3_ma5_e6 := ta.ema(t3_ma5_e5, maLength5)
t3_ma5 := c1_ma * t3_ma5_e6 + c2_ma * t3_ma5_e5 + c3_ma * t3_ma5_e4 + c4_ma * t3_ma5_e3

// HMA bar calculation
if boolhmabar
    hma := ta.hma(close, hmabar)
    hmacolor := close > hma ? color.lime : color.red

// Modified getMA function that uses pre-calculated values
getMA(string type, int length) =>
    float result = ema_ma1  // Default initialization
    
    if length == maLength1
        if type == "EMA"
            result := ema_ma1
        else if type == "SMA"
            result := sma_ma1
        else if type == "HMA"
            result := hma_ma1
        else if type == "WMA"
            result := wma_ma1
        else if type == "DEMA"
            result := dema_ma1
        else if type == "T3"
            result := t3_ma1
    else if length == maLength2
        if type == "EMA"
            result := ema_ma2
        else if type == "SMA"
            result := sma_ma2
        else if type == "HMA"
            result := hma_ma2
        else if type == "WMA"
            result := wma_ma2
        else if type == "DEMA"
            result := dema_ma2
        else if type == "T3"
            result := t3_ma2
    else if length == maLength3
        if type == "EMA"
            result := ema_ma3
        else if type == "SMA"
            result := sma_ma3
        else if type == "HMA"
            result := hma_ma3
        else if type == "WMA"
            result := wma_ma3
        else if type == "DEMA"
            result := dema_ma3
        else if type == "T3"
            result := t3_ma3
    else if length == maLength4
        if type == "EMA"
            result := ema_ma4
        else if type == "SMA"
            result := sma_ma4
        else if type == "HMA"
            result := hma_ma4
        else if type == "WMA"
            result := wma_ma4
        else if type == "DEMA"
            result := dema_ma4
        else if type == "T3"
            result := t3_ma4
    else if length == maLength5
        if type == "EMA"
            result := ema_ma5
        else if type == "SMA"
            result := sma_ma5
        else if type == "HMA"
            result := hma_ma5
        else if type == "WMA"
            result := wma_ma5
        else if type == "DEMA"
            result := dema_ma5
        else if type == "T3"
            result := t3_ma5
    
    result

// Get the MA values using the modified function
var float out1 = na
var float out2 = na
var float out3 = na
var float out4 = na
var float out5 = na

// Update MA outputs
out1 := getMA(maType1, maLength1)
out2 := getMA(maType2, maLength2)
out3 := getMA(maType3, maLength3)
out4 := getMA(maType4, maLength4)
out5 := getMA(maType5, maLength5)

// MA Conditions - Fixed: Changed from 'const bool' to 'var bool'
var bool ma1CrossUp2 = false
var bool ma1CrossDn2 = false
var bool ma1Con = false
var bool ma2Con = false
var bool longema_ordered = false
var bool shortema_ordered = false
var bool long_ema_checked = false
var bool short_ema_checked = false
var bool long_ema_checked_strict = false
var bool short_ema_checked_strict = false
var bool long_ema_checked_cross = false
var bool short_ema_checked_cross = false

// Update MA conditions on each bar
ma1CrossUp2 := ta.crossover(out1, out5)
ma1CrossDn2 := ta.crossunder(out1, out5)
ma1Con := out1 >= out1[1]
ma2Con := out5 >= out5[1]
longema_ordered := close > out5 and out1 > out2 and out2 > out3 and out3 > out4 and out4 > out5
shortema_ordered := close < out5 and out1 < out2 and out2 < out3 and out3 < out4 and out4 < out5
long_ema_checked := out1 > out2 and out2 > out5 and out1 > out5
short_ema_checked := out1 < out2 and out2 < out5 and out1 < out5
long_ema_checked_strict := out1 > out5
short_ema_checked_strict := out1 < out5
long_ema_checked_cross := out1 > out2 and out1[1] < out2[1] and out2 > out5 and out1 > out5
short_ema_checked_cross := out1 < out2 and out1[1] > out2[1] and out2 < out5 and out1 < out5

// Determine ema_theema conditions
var bool ema_theema_long = true
var bool ema_theema_short = true

if useMA == "Close over/under MA5"
    ema_theema_long := close > out5
    ema_theema_short := close < out5
else if useMA == "Strict Close over/under MA5"
    ema_theema_long := close > out5 and close[1] > out5[1]
    ema_theema_short := close < out5 and close[1] < out5[1]
else if useMA == "5 MA (Ordered)"
    ema_theema_long := longema_ordered
    ema_theema_short := shortema_ordered
else if useMA == "3 MA (Ordered)"
    ema_theema_long := long_ema_checked
    ema_theema_short := short_ema_checked
else if useMA == "3 MA (Strict)"
    ema_theema_long := long_ema_checked_strict
    ema_theema_short := short_ema_checked_strict
else if useMA == "3 MA (Cross)"
    ema_theema_long := long_ema_checked_cross
    ema_theema_short := short_ema_checked_cross
else
    ema_theema_long := true
    ema_theema_short := true

// Apply MA inversions if requested
if inverseMA
    bool temp = ema_theema_long
    ema_theema_long := not ema_theema_short
    ema_theema_short := not temp

// HMA bar conditions
if boolhmabar
    ema_theema_long := ema_theema_long and close > hma
    ema_theema_short := ema_theema_short and close < hma

// ----------------------
// Function to check if a new trade is allowed based on max trades per direction
// ----------------------
canTakeNewTrade(bool isLongTrade) =>
    bool result = true  // Default to allow trades
    if enableMaxTrades
        if isLongTrade
            // Check if we've reached max consecutive long trades
            result := longTradesCount < maxTradesPerDirection
        else
            // Check if we've reached max consecutive short trades
            result := shortTradesCount < maxTradesPerDirection
    result

// ----------------------
// T3 Indicator Calculation
// ----------------------
var line t3Line = na
var float t3Value = na

if useT3
    // Map t3Source to the appropriate price data
    float sourcePrice = t3Source == "open" ? open :
                  t3Source == "high" ? high :
                  t3Source == "low" ? low :
                  t3Source == "close" ? close :
                  t3Source == "hl2" ? hl2 :
                  t3Source == "hlc3" ? hlc3 :
                  t3Source == "ohlc4" ? ohlc4 :
                  t3Source == "hlcc4" ? hlcc4 : close  // Default to close if no match
    
    // Use sourcePrice for T3 calculation
    float xe1 = ta.ema(sourcePrice, t3Length)
    float xe2 = ta.ema(xe1, t3Length)
    float xe3 = ta.ema(xe2, t3Length)
    float xe4 = ta.ema(xe3, t3Length)
    float xe5 = ta.ema(xe4, t3Length)
    float xe6 = ta.ema(xe5, t3Length)
    float b = t3Factor
    float c1 = -b * b * b
    float c2 = 3 * b * b + 3 * b * b * b
    float c3 = -6 * b * b - 3 * b - 3 * b * b * b
    float c4 = 1 + 3 * b + b * b + 3 * b * b
    t3Value := c1 * xe6 + c2 * xe5 + c3 * xe4 + c4 * xe3
    
else
    t3Value := na

// ----------------------
// Trendilio Indicator Calculation
// ----------------------
var float pch = na
var float avpch = na
//var float avpchSmoothed = 0.0
var float rms = na
var float d_avpch = na
var float smoothed_davpch = 0.0
var bool osCondition = false
var bool obCondition = false
var bool trendEntryLong = false
var bool trendEntryShort = false
var bool trendExitLong = false
var bool trendExitShort = false
var bool exitOS = false
var bool exitOB = false
var bool enterOS = false
var bool enterOB = false
var bool momentum_was_positive = false
var bool momentum_was_negative = false
var int momentum_cooldown = 0

if useTrendilio
    // Use custom band length if enabled; otherwise use the default lookbackTrendilio
    int trendBandLength = customBandLengthTrendilio ? customBandLengthTrendilioValue : lookbackTrendilio
    
    // Map TrendilioSource to the appropriate price data
    float sourcePrice = TrendilioSource == "open" ? open :
                  TrendilioSource == "high" ? high :
                  TrendilioSource == "low" ? low :
                  TrendilioSource == "close" ? close :
                  TrendilioSource == "hl2" ? hl2 :
                  TrendilioSource == "hlc3" ? hlc3 :
                  TrendilioSource == "ohlc4" ? ohlc4 :
                  TrendilioSource == "hlcc4" ? hlcc4 : close  // Default to close if no match
    
    // Use sourcePrice for pch calculation
    pch := ta.change(sourcePrice, smoothTrending) / sourcePrice * 100
    avpch := ta.alma(pch, trendBandLength, almaOffsetTrend, almaSigma)
    
    // Apply additional smoothing to avpch for more stability
    avpchSmoothed := 0.7 * avpch + 0.3 * nz(avpchSmoothed[1])
    
    rms := bandMultiplier * math.sqrt(math.sum(avpch * avpch, trendBandLength) / trendBandLength)
    d_avpch := avpch - avpch[1]
    
    // Apply smoothing to d_avpch as well
    smoothed_davpch := 0.6 * d_avpch + 0.4 * nz(smoothed_davpch[1])
    
    // Decrement cooldown counter
    if trendilioSignalCooldownCounter > 0
        trendilioSignalCooldownCounter := trendilioSignalCooldownCounter - 1
    
    // Base conditions with smoother transitions
    osCondition := useTrendilio and (avpchSmoothed < -rms)      // Oversold zone
    obCondition := useTrendilio and (avpchSmoothed > rms)       // Overbought zone
    exitOS := ta.crossover(avpchSmoothed, -rms)            // Exit oversold
    exitOB := ta.crossunder(avpchSmoothed, rms)            // Exit overbought
    enterOS := ta.crossunder(avpchSmoothed, -rms)          // Cross into oversold
    enterOB := ta.crossover(avpchSmoothed, rms)            // Cross into overbought
    
    // Initialize trade conditions to false
    trendEntryLong := false
    trendEntryShort := false
    trendExitLong := false
    trendExitShort := false
    
    // Only apply Trendilio logic if the cooldown period is over
    if trendilioSignalCooldownCounter == 0
        // Trendilio Trade Type Logic with improved debouncing
        if trendilioTradeType == "OS/OB"
            trendEntryLong := osCondition and not lastSignalWasLong
            trendEntryShort := obCondition and not lastSignalWasShort
            trendExitLong := exitOS
            trendExitShort := exitOB
            
            // Update state tracking
            if trendEntryLong
                lastSignalWasLong := true
                lastSignalWasShort := false
                trendilioSignalCooldownCounter := trendilioSignalCooldownPeriod
            else if trendEntryShort
                lastSignalWasLong := false
                lastSignalWasShort := true
                trendilioSignalCooldownCounter := trendilioSignalCooldownPeriod
        
        else if trendilioTradeType == "OS/OB enter"
            trendEntryLong := enterOS and not lastSignalWasLong
            trendEntryShort := enterOB and not lastSignalWasShort
            trendExitLong := exitOS
            trendExitShort := exitOB
            
            // Update state tracking
            if trendEntryLong
                lastSignalWasLong := true
                lastSignalWasShort := false
                trendilioSignalCooldownCounter := trendilioSignalCooldownPeriod
            else if trendEntryShort
                lastSignalWasLong := false
                lastSignalWasShort := true
                trendilioSignalCooldownCounter := trendilioSignalCooldownPeriod
        
        else if trendilioTradeType == "OS/OB exit"
            // Standard behavior - enter on zone, exit on crossover
            trendEntryLong := osCondition and not lastSignalWasLong
            trendEntryShort := obCondition and not lastSignalWasShort
            trendExitLong := exitOS  // Keep this simple - exit only when leaving zone
            trendExitShort := exitOB // Keep this simple - exit only when leaving zone
            
            // Update state tracking
            if trendEntryLong
                lastSignalWasLong := true
                lastSignalWasShort := false
                trendilioSignalCooldownCounter := trendilioSignalCooldownPeriod
            else if trendEntryShort
                lastSignalWasLong := false
                lastSignalWasShort := true
                trendilioSignalCooldownCounter := trendilioSignalCooldownPeriod
            
            // Reset state on exits
            if trendExitLong
                lastSignalWasLong := false
                trendilioSignalCooldownCounter := trendilioSignalCooldownPeriod
            else if trendExitShort
                lastSignalWasShort := false
                trendilioSignalCooldownCounter := trendilioSignalCooldownPeriod
        
        else if trendilioTradeType == "OS/OB reverse"
            // Use smoothed momentum and momentum state for more stability
            bool momentum_is_positive = smoothed_davpch > 0 and smoothed_davpch[1] > 0 and smoothed_davpch[2] > 0
            bool momentum_is_negative = smoothed_davpch < 0 and smoothed_davpch[1] < 0 and smoothed_davpch[2] < 0
            
            trendEntryLong := osCondition and momentum_is_positive and not lastSignalWasLong
            trendEntryShort := obCondition and momentum_is_negative and not lastSignalWasShort
            trendExitLong := exitOS or (momentum_is_negative and not momentum_was_negative)
            trendExitShort := exitOB or (momentum_is_positive and not momentum_was_positive)
            
            // Update state tracking
            if trendEntryLong
                lastSignalWasLong := true
                lastSignalWasShort := false
                trendilioSignalCooldownCounter := trendilioSignalCooldownPeriod
            else if trendEntryShort
                lastSignalWasLong := false
                lastSignalWasShort := true
                trendilioSignalCooldownCounter := trendilioSignalCooldownPeriod
            
            // Update momentum tracking
            momentum_was_positive := momentum_is_positive
            momentum_was_negative := momentum_is_negative
        
        else if trendilioTradeType == "OS/OB enter reverse"
            bool momentum_is_positive = smoothed_davpch > 0 and smoothed_davpch[1] > 0
            bool momentum_is_negative = smoothed_davpch < 0 and smoothed_davpch[1] < 0
            
            trendEntryLong := enterOS and momentum_is_positive and not lastSignalWasLong
            trendEntryShort := enterOB and momentum_is_negative and not lastSignalWasShort
            trendExitLong := exitOS or (momentum_is_negative and not momentum_was_negative)
            trendExitShort := exitOB or (momentum_is_positive and not momentum_was_positive)
            
            // Update state tracking
            if trendEntryLong
                lastSignalWasLong := true
                lastSignalWasShort := false
                trendilioSignalCooldownCounter := trendilioSignalCooldownPeriod
            else if trendEntryShort
                lastSignalWasLong := false
                lastSignalWasShort := true
                trendilioSignalCooldownCounter := trendilioSignalCooldownPeriod
            
            // Update momentum tracking
            momentum_was_positive := momentum_is_positive
            momentum_was_negative := momentum_is_negative
        
        else if trendilioTradeType == "OS/OB reverse exit"
            // Modified behavior to prevent rapid cycling
            trendEntryLong := osCondition and not exitOS and not lastSignalWasLong  // Only enter if not also exiting
            trendEntryShort := obCondition and not exitOB and not lastSignalWasShort // Only enter if not also exiting
        
            trendExitLong := exitOS or (smoothed_davpch < 0 and smoothed_davpch[1] < 0 and smoothed_davpch[2] < 0)
            trendExitShort := exitOB or (smoothed_davpch > 0 and smoothed_davpch[1] > 0 and smoothed_davpch[2] > 0)
            
            // Update state tracking
            if trendEntryLong
                lastSignalWasLong := true
                lastSignalWasShort := false
                trendilioSignalCooldownCounter := trendilioSignalCooldownPeriod
            else if trendEntryShort
                lastSignalWasLong := false
                lastSignalWasShort := true
                trendilioSignalCooldownCounter := trendilioSignalCooldownPeriod
            
            // Reset state on exits
            if trendExitLong
                lastSignalWasLong := false
                trendilioSignalCooldownCounter := trendilioSignalCooldownPeriod
            else if trendExitShort
                lastSignalWasShort := false
                trendilioSignalCooldownCounter := trendilioSignalCooldownPeriod
else
    pch := 0
    avpch := 0
    rms := 0
    d_avpch := 0
    osCondition := false
    obCondition := false
    trendEntryLong := false
    trendEntryShort := false
    trendExitLong := false
    trendExitShort := false
    exitOS := false
    exitOB := false
    enterOS := false
    enterOB := false

// ----------------------
// WAE Indicator Calculation
// ----------------------
var line waeExplosionLine = na
var float e1 = na
var float t1 = na
var float e1_prev = na
var float e1_to_plot = na
var float t1_to_plot = na
var float trendUp = na
var float trendDown = na

if useWAE
    t1 := (ta.ema(close, fastEMALength) - ta.ema(close, slowEMALength)) * waeSensitivity
    e1 := bbStdevMultiplier * ta.stdev(t1, bbChannelLength)  // Dynamic threshold
    trendUp := t1 >= 0 ? t1 : 0
    trendDown := t1 < 0 ? -t1 : 0

    t1_to_plot := t1
    
else
    e1 := na
    t1 := na
    t1_to_plot := na
    e1_to_plot := na
    trendUp := 0
    trendDown := 0

// ----------------------
// Early Exit Protection Calculation
// ----------------------
var float earlyExitMA = na
float protectionSrc = indicatorSourceProtection == "open" ? open : 
                     indicatorSourceProtection == "high" ? high : 
                     indicatorSourceProtection == "low" ? low : 
                     indicatorSourceProtection == "close" ? close : 
                     indicatorSourceProtection == "hl2" ? hl2 : 
                     indicatorSourceProtection == "hlc3" ? hlc3 : 
                     indicatorSourceProtection == "ohlc3" ? ohlc4 : 
                     indicatorSourceProtection == "hlcc4" ? (high + low + close + close) / 4 : close

if maProtectionType == "EMA"
    earlyExitMA := ta.ema(protectionSrc, maProtectionLength)
else if maProtectionType == "SMA"
    earlyExitMA := ta.sma(protectionSrc, maProtectionLength)
else if maProtectionType == "HMA"
    earlyExitMA := ta.hma(protectionSrc, maProtectionLength)
else if maProtectionType == "WMA"
    earlyExitMA := ta.wma(protectionSrc, maProtectionLength)
else if maProtectionType == "DEMA"
    float ema1_val = ta.ema(protectionSrc, maProtectionLength)
    float ema2_val = ta.ema(ema1_val, maProtectionLength)
    earlyExitMA := 2 * ema1_val - ema2_val
else if maProtectionType == "VWMA"
    earlyExitMA := ta.vwma(protectionSrc, maProtectionLength)
else if maProtectionType == "VWAP"
    earlyExitMA := ta.vwap(protectionSrc)
else if maProtectionType == "T3"
    float vFactor = 0.7
    float e1_val = ta.ema(protectionSrc, maProtectionLength)
    float e2_val = ta.ema(e1_val, maProtectionLength)
    float e3_val = ta.ema(e2_val, maProtectionLength)
    float e4_val = ta.ema(e3_val, maProtectionLength)
    float e5_val = ta.ema(e4_val, maProtectionLength)
    float e6_val = ta.ema(e5_val, maProtectionLength)
    float c1_val = -vFactor * vFactor * vFactor
    float c2_val = 3 * vFactor * vFactor + 3 * vFactor * vFactor * vFactor
    float c3_val = -6 * vFactor * vFactor - 3 * vFactor - 3 * vFactor * vFactor * vFactor
    float c4_val = 1 + 3 * vFactor + vFactor * vFactor + 3 * vFactor * vFactor
    earlyExitMA := c1_val * e6_val + c2_val * e5_val + c3_val * e4_val + c4_val * e3_val
else
    earlyExitMA := ta.ema(protectionSrc, maProtectionLength)  // Default to EMA


// ----------------------
// Base Entry and Exit Conditions Implementation
// ----------------------
// T3 Conditions
var bool t3LongCondition = false
var bool t3ShortCondition = false
if useT3
    t3LongCondition := t3Value > t3Value[1]
    t3ShortCondition := t3Value < t3Value[1]
else
    t3LongCondition := true
    t3ShortCondition := true

// WAE Conditions
var bool waeLongCondition = false
var bool waeShortCondition = false
if useWAE
    waeLongCondition := useExplosionLine ? t1 > e1 : trendUp > noTradeZoneThreshold
    waeShortCondition := useExplosionLine ? t1 < -e1 : trendDown > noTradeZoneThreshold
else
    waeLongCondition := true
    waeShortCondition := true

// Final Entry Conditions
var bool longCondition = false
var bool shortCondition = false

// Update entry conditions on each bar
longCondition := (useT3 ? t3LongCondition : true) and 
                 (useTrendilio ? trendEntryLong : true) and 
                 (useWAE ? waeLongCondition : true) and 
                 ema_theema_long and 
                 TradeDateIsAllowed() and 
                 TradeDayIsAllowed() and 
                 LiveTradeIsAllowed() and 
                 longTrades and 
                 canTakeNewTrade(true) and 
                 (bar_index > lastEntryCandle + waitCandlesBetweenEntries or waitCandlesBetweenEntries <= 0)

shortCondition := (useT3 ? t3ShortCondition : true) and 
                  (useTrendilio ? trendEntryShort : true) and 
                  (useWAE ? waeShortCondition : true) and 
                  ema_theema_short and 
                  TradeDateIsAllowed() and 
                  TradeDayIsAllowed() and 
                  LiveTradeIsAllowed() and 
                  shortTrades and 
                  canTakeNewTrade(false) and 
                  (bar_index > lastEntryCandle + waitCandlesBetweenEntries or waitCandlesBetweenEntries <= 0)

// ----------------------
// Global Filter Variables
// ----------------------
var bool rangeFilterCondition = true      // Range Filter
var bool volumeFlowLongCondition = true   // Volume Flow
var bool volumeFlowShortCondition = true  
var bool adxLongCondition = true          // ADX
var bool adxShortCondition = true         
var bool tdfiLongCondition = true         // TDFI
var bool tdfiShortCondition = true        
var bool flatMarketCondition = true       // Flat Market
var bool hurstCondition = true            // Hurst
var bool bullBearLongCondition = true     // Bull Bear Power
var bool bullBearShortCondition = true    
var bool vwapLongCondition = true         // VWAP
var bool vwapShortCondition = true     
var bool planetaryLongCondition = true   // Planetary Hours
var bool planetaryShortCondition = true

// ----------------------
// Range Filter Implementation
// ----------------------
var float rangeLow = na
var float rangeHigh = na

// Range calculation - recalculated every bar
rangeFilterCondition := true  // Reset to default
if useRangeFilter
    rangeLow := ta.lowest(low, rfPeriod)
    rangeHigh := ta.highest(high, rfPeriod)
    float priceRange = (rangeHigh - rangeLow) / rangeLow * 100
    float avgRange = ta.sma(priceRange, rfPeriod)
    float rangeThreshold = avgRange * rfMulti

    // Create range filter condition
    rangeFilterCondition := priceRange > rangeThreshold

// ----------------------
// Volume Flow Implementation
// ----------------------
var float vfi = 0.0

// Reset to default values
volumeFlowLongCondition := true
volumeFlowShortCondition := true

if enableVolumeFlow
    // VFI calculation based on input parameters
    // Typical price
    float typ = hlc3
    
    // Inter-bar volatility
    float inter = math.abs(typ - typ[1])
    
    // Calculate cutoff based on inter-volatility multiplied by coefficient
    float cutoff = ta.sma(inter, vfiLength) * coef
    
    // Calculate maximum volume cutoff to filter out extreme volume
    float max_vol = ta.sma(volume, vfiLength) * maxVolCutoff
    
    // Calculate price direction
    float price_delta = typ - typ[1]
    
    // Calculate VFI using volatility-adjusted volume
    vfi := 0.0  // Reset VFI
    for i = 0 to vfiLength - 1
        // Skip current bar in the loop
        if i == 0
            vfi := vfi
        else
            // Get historical values
            float historic_price_delta = price_delta[i]
            float historic_inter = inter[i]
            float historic_cutoff = cutoff[i]
            float historic_volume = math.min(volume[i], max_vol[i])
            
            // Determine direction of volume (positive or negative)
            float vcp = historic_price_delta > 0 ? 1 : historic_price_delta < 0 ? -1 : 0
            
            // Add to vfi if inter-volatility is significant
            if historic_inter > historic_cutoff
                vfi := vfi + vcp * historic_volume / historic_inter
    
    // Normalize and smooth the VFI
    vfi := vfi / vfiLength
    vfi := ta.ema(vfi, 3)  // Additional smoothing
    
    // Create volume flow condition
    volumeFlowLongCondition := vfi > 0
    volumeFlowShortCondition := vfi < 0

// ----------------------
// ADX Implementation
// ----------------------
var float adxValue = 0.0
var float plusDI = 0.0
var float minusDI = 0.0

if enableADX
    // Standard ADX calculation
    if adxType == "Normal"
        // Declare temporary variables directly with destructuring
        [temp_adx, temp_plus, temp_minus] = ta.dmi(adxSmoothing, adxSmoothing)
        // Transfer to global variables
        adxValue := temp_adx
        plusDI := temp_plus
        minusDI := temp_minus
    
    // Stochastic ADX calculation
    else if adxType == "Stoch"
        [standardADX, standardPlusDI, standardMinusDI] = ta.dmi(adxSmoothing, adxSmoothing)
        adxValue := ta.stoch(standardADX, standardADX, standardADX, maxStochLength)
        adxValue := ta.sma(adxValue, stochSmoothing)
        plusDI := standardPlusDI
        minusDI := standardMinusDI
    
    // Masa Nakamura-style ADX
    else if adxType == "MasaNakamura"
        float tr = ta.tr(true)
        float atr = ta.ema(tr, adxSmoothing)
        float up = high - high[1]
        float down = low[1] - low
        float plusDM = up > down and up > 0 ? up : 0
        float minusDM = down > up and down > 0 ? down : 0
        plusDI := 100 * ta.ema(plusDM, adxSmoothing) / atr
        minusDI := 100 * ta.ema(minusDM, adxSmoothing) / atr
        float dx = math.abs(plusDI - minusDI) / (plusDI + minusDI) * 100
        adxValue := ta.ema(dx, adxSmoothing)
    
    // Apply moving average transformation if selected
    if adxLineType != "Static"
        if adxLineType == "MA"
            adxValue := ta.sma(adxValue, adxMALength)
        else if adxLineType == "EMA"
            adxValue := ta.ema(adxValue, adxMALength)
        else if adxLineType == "SMA"
            adxValue := ta.sma(adxValue, adxMALength)
        else if adxLineType == "HMA"
            adxValue := ta.hma(adxValue, adxMALength)
        else if adxLineType == "WMA"
            adxValue := ta.wma(adxValue, adxMALength)
        else if adxLineType == "DEMA"
            float e1_adx = ta.ema(adxValue, adxMALength)
            float e2_adx = ta.ema(e1_adx, adxMALength)
            adxValue := 2 * e1_adx - e2_adx
        else if adxLineType == "VWMA"
            adxValue := ta.vwma(adxValue, adxMALength)
        else if adxLineType == "T3"
            float vFactor_adx = 0.7
            float e1_adx_t3 = ta.ema(adxValue, adxMALength)
            float e2_adx_t3 = ta.ema(e1_adx_t3, adxMALength)
            float e3_adx_t3 = ta.ema(e2_adx_t3, adxMALength)
            float e4_adx_t3 = ta.ema(e3_adx_t3, adxMALength)
            float e5_adx_t3 = ta.ema(e4_adx_t3, adxMALength)
            float e6_adx_t3 = ta.ema(e5_adx_t3, adxMALength)
            float c1_adx = -vFactor_adx * vFactor_adx * vFactor_adx
            float c2_adx = 3 * vFactor_adx * vFactor_adx + 3 * vFactor_adx * vFactor_adx * vFactor_adx
            float c3_adx = -6 * vFactor_adx * vFactor_adx - 3 * vFactor_adx - 3 * vFactor_adx * vFactor_adx * vFactor_adx
            float c4_adx = 1 + 3 * vFactor_adx + vFactor_adx * vFactor_adx + 3 * vFactor_adx * vFactor_adx
            adxValue := c1_adx * e6_adx_t3 + c2_adx * e5_adx_t3 + c3_adx * e4_adx_t3 + c4_adx * e3_adx_t3
    
    // Rate of change logic for ADX - fixed implementation
    var float adxAboveLineValue = 0.0
    if useRateOfChange
        float adxRateOfChange = adxValue - adxValue[3]
        float adxAboveLineAdaptive = adxRateOfChange > 0 ? adxAboveLine * 0.9 : adxAboveLine * 1.1
        adxAboveLineValue := adxAboveLineAdaptive
    else
        adxAboveLineValue := adxAboveLine
    
    // Create ADX conditions - fixed implementation
    bool adxStrengthCondition = adxValue > adxAboveLineValue
    
    // Apply directional indicators if enabled - fixed implementation
    if useDI
        bool diLongCondition = plusDI > minusDI
        bool diShortCondition = minusDI > plusDI
        
        // Check if we need to inverse the ADX logic
        if inverseAdaptive
            adxLongCondition := adxStrengthCondition and diShortCondition  // Inverted DI
            adxShortCondition := adxStrengthCondition and diLongCondition  // Inverted DI
        else
            adxLongCondition := adxStrengthCondition and diLongCondition
            adxShortCondition := adxStrengthCondition and diShortCondition
    else
        // Without DI, just use ADX strength, potentially inverted
        if inverseAdaptive
            adxLongCondition := not adxStrengthCondition  // Invert the condition
            adxShortCondition := not adxStrengthCondition  // Invert the condition
        else
            adxLongCondition := adxStrengthCondition
            adxShortCondition := adxStrengthCondition
else
    // Default values when ADX is disabled
    adxLongCondition := true
    adxShortCondition := true

// ----------------------
// TDFI (Trend Direction Force Index) Implementation
// ----------------------
var float tdfi = 0.0

// Reset to default values
tdfiLongCondition := true
tdfiShortCondition := true

// Define helper functions for TDFI v2 at script level
getMMA(src, len, mode) =>
    float result = ta.ema(src, len)  // Default
    if mode == "ema"
        result := ta.ema(src, len)
    else if mode == "wma"
        result := ta.wma(src, len)
    else if mode == "swma"
        result := ta.swma(src)
    else if mode == "vwma"
        result := ta.vwma(src, len)
    else if mode == "hull"
        result := ta.hma(src, len)
    else if mode == "tema"
        float e1_tema = ta.ema(src, len)
        float e2_tema = ta.ema(e1_tema, len)
        float e3_tema = ta.ema(e2_tema, len)
        result := 3 * (e1_tema - e2_tema) + e3_tema
    result

getSMMA(src, len, mode) =>
    float result = ta.ema(src, len)  // Default
    if mode == "ema"
        result := ta.ema(src, len)
    else if mode == "wma"
        result := ta.wma(src, len)
    else if mode == "swma"
        result := ta.swma(src)
    else if mode == "vwma"
        result := ta.vwma(src, len)
    else if mode == "hull"
        result := ta.hma(src, len)
    else if mode == "tema"
        float e1_tdfi = ta.ema(src, len)
        float e2_tdfi = ta.ema(e1_tdfi, len)
        float e3_tdfi = ta.ema(e2_tdfi, len)
        result := 3 * (e1_tdfi - e2_tdfi) + e3_tdfi
    result

// TDFI Logic
if enableTDFI
    // TDFI Version 1 - Basic implementation
    if tdfiVersion == "v1"
        float price_diff = close - close[1]
        float raw_force = price_diff * volume
        tdfi := ta.ema(raw_force, 13) / ta.ema(volume, 13) / close * 100
    
    // TDFI Version 2 - Enhanced implementation
    else if tdfiVersion == "v2"
        float priceChange = close - close[nLengthV2]
        float volumeF = volume / ta.sma(volume, 100)
        float raw_force_v2 = priceChange * volumeF
        float mma_raw_force = getMMA(raw_force_v2, mmaLengthV2, mmaModeV2)
        float normalized_force = mma_raw_force / close * 100
        tdfi := getSMMA(normalized_force, mmaLengthV2, smmaModeV2)
    
    // Create TDFI conditions
    tdfiLongCondition := tdfi > tdfiHigh
    tdfiShortCondition := tdfi < tdfiLow

// ----------------------
// Flat Market Implementation
// ----------------------
var float flatMarketValue = 0.0
var float flatMarketRoC = 0.0

// Function to get the Moving Average for flat market detection
getMAflat(source, maType, length) =>
    float result = switch 
        maType == "MA" or maType == "SMA" => ta.sma(source, length)
        maType == "EMA" => ta.ema(source, length)
        maType == "HMA" => ta.hma(source, length)
        maType == "WMA" => ta.wma(source, length)
        maType == "DEMA" => 
            float ema1 = ta.ema(source, length)
            float ema2 = ta.ema(ema1, length)
            2 * ema1 - ema2
        maType == "VWMA" => ta.vwma(source, length)
        maType == "T3" => 
            float factor = 0.7
            float t3_e1 = ta.ema(source, length)
            float t3_e2 = ta.ema(t3_e1, length)
            float t3_e3 = ta.ema(t3_e2, length)
            float t3_e4 = ta.ema(t3_e3, length)
            float t3_e5 = ta.ema(t3_e4, length)
            float t3_e6 = ta.ema(t3_e5, length)
            float c1 = -factor * factor * factor
            float c2 = 3 * factor * factor + 3 * factor * factor * factor
            float c3 = -6 * factor * factor - 3 * factor - 3 * factor * factor * factor
            float c4 = 1 + 3 * factor + factor * factor + 3 * factor * factor
            c1 * t3_e6 + c2 * t3_e5 + c3 * t3_e4 + c4 * t3_e3
        => source

    result

// Function to calculate Rate of Change
getROC(source, length) =>
    (source / source[length] - 1) * 100

// Calculate Flat Market condition
if enableFlatMarket
    // Get price volatility (using HLC3 as default source)
    float choppy = ta.atr(1) / ta.atr(maLengthFlatMarket) * 100
    
    // Calculate and apply moving average if not using "Static" type
    float choppyline = choppy
    choppyline := maTypeFlatMarket != "Static" ? getMAflat(choppy, maTypeFlatMarket, maLengthFlatMarket) : choppy
    
    // Check if the market is flat or not
    flatMarketCondition := if useRateOfChangeFlat
        // With Rate of Change - market is tradable (not flat) when:
        // 1. For long trades: RoC is positive and choppyline is above threshold
        // 2. For short trades: RoC is negative and choppyline is above threshold
        float roc = getROC(choppy, 9)
        bool notFlatForLong = roc > 0 and choppyline > flatMarketAboveLine
        bool notFlatForShort = roc < 0 and choppyline > flatMarketAboveLine
        
        notFlatForLong or notFlatForShort
    else
        // Without Rate of Change - market is tradable (not flat) when:
        // Volatility is above the threshold
        choppyline > flatMarketAboveLine

// ----------------------
// Hurst Exponent Implementation
// ----------------------
var float hurstExponent = 0.5  // Default to 0.5 (random walk)
var float rs = 1.0  // Default safe value

// Reset to default value
hurstCondition := true

if enableHurst
    // Calculate Hurst Exponent
    // Using rescaled range method
    
    // Step 1: Calculate returns
    float returns = close / close[1] - 1
    
    // Step 2: Calculate cumulative deviation from mean
    float meanReturn = ta.cum(returns) / hurstExpLength
    float deviation = returns - meanReturn
    float cumDeviation = ta.cum(deviation)
    
    // Step 3: Calculate range and standard deviation
    float maxCumDev = ta.highest(cumDeviation, hurstExpLength)
    float minCumDev = ta.lowest(cumDeviation, hurstExpLength)
    float rangeRS = maxCumDev - minCumDev
    
    float stdev = math.sqrt(ta.cum(math.pow(returns - meanReturn, 2)) / hurstExpLength)
    
    // Step 4: Calculate R/S statistic
    if stdev != 0
        rs := rangeRS / stdev
    else
        rs := 1
    
    // Step 5: Estimate Hurst exponent (approximation)
    // H = log(R/S) / log(N) where N is the time period
    if rs > 0
        hurstExponent := math.log(rs) / math.log(hurstExpLength)
    
    // Create Hurst condition based on market type
    if hurstType == "Trending Market"
        // Trending market: H > 0.5
        hurstCondition := hurstExponent > 0.5
    else if hurstType == "Consolidation"
        // Consolidation: H < 0.5
        hurstCondition := hurstExponent < 0.5
    else  // "Random Walk"
        // Random walk: H ≈ 0.5
        hurstCondition := hurstExponent >= 0.4 and hurstExponent <= 0.6

// ----------------------
// Bull Bear Power Implementation
// ----------------------
var float bullPower = 0.0
var float bearPower = 0.0

// Reset to default values
bullBearLongCondition := true
bullBearShortCondition := true

if enableBullBear
    // Calculate EMA for bull/bear power basis
    float ema = ta.ema(close, bbpLength)
    
    // Calculate Bull Power and Bear Power
    bullPower := high - ema
    bearPower := low - ema
    
    // Create conditions for bull and bear power
    bool bullPowerCondition = bullPower > 0 and bullPower > bullPower[1]
    bool bearPowerCondition = bearPower < 0 and bearPower < bearPower[1]
    
    // Apply to strategy signals
    bullBearLongCondition := bullPowerCondition and bearPower > bearPower[1]  // Bull strong & bear weakening
    bullBearShortCondition := bearPowerCondition and bullPower < bullPower[1]  // Bear strong & bull weakening

// ----------------------
// VWAP Crossover Implementation
// ----------------------
// Initialize VWAP variables
var float valslow = 0.0
var float sma_close = 0.0

// Reset conditions at beginning of each bar
vwapLongCondition := true
vwapShortCondition := true

// Calculate VWAP filter conditions
if useVWAPEMA
    // Get price sources
    float vwapSrc = getSourcePrice(vwapSource)
    float vwap2Src = getSourcePrice(vwap2Source)
    
    // Calculate VWAP and SMA
    valslow := ta.vwap(vwapSrc)  // Using built-in vwap for better performance
    sma_close := ta.ema(vwap2Src, vwapLength)  // Using EMA instead of SMA for better responsiveness
    
    // Set VWAP conditions based on previous bar's values
    vwapLongCondition := valslow[1] < sma_close[1]
    vwapShortCondition := valslow[1] > sma_close[1]

// ----------------------
// Planetary Hours Functions
// ----------------------
getPlanetaryHour() =>
    hour_of_day = hour(time)
    day_of_week = dayofweek(time)
    var planetary_sequence = array.new_int(7)
    array.set(planetary_sequence, 0, 0)  // Sun
    array.set(planetary_sequence, 1, 1)  // Venus
    array.set(planetary_sequence, 2, 2)  // Mercury
    array.set(planetary_sequence, 3, 3)  // Moon
    array.set(planetary_sequence, 4, 4)  // Saturn
    array.set(planetary_sequence, 5, 5)  // Jupiter
    array.set(planetary_sequence, 6, 6)  // Mars
    hour_index = (hour_of_day + (day_of_week - 1) * 24) % 7
    array.get(planetary_sequence, hour_index)

isPlanetHour(string planet) =>
    planetary_hour = getPlanetaryHour()
    planet_index = switch planet
        "Sun" => 0
        "Venus" => 1
        "Mercury" => 2
        "Moon" => 3
        "Saturn" => 4
        "Jupiter" => 5
        "Mars" => 6
        "None" => -1  // Special case for no force exit
        => 1  // Default to Venus if invalid
    planet_condition = planetary_hour == planet_index
    planet_condition

// ----------------------
// Custom External Indicators Comparison Implementation
// ----------------------
// Define a function to perform the comparison
f_compare(source1, source2, operator) =>
    var bool comparison = false
    if operator == ">"
        comparison := source1 > source2
    else if operator == "<"
        comparison := source1 < source2
    else if operator == ">="
        comparison := source1 >= source2
    else if operator == "<="
        comparison := source1 <= source2
    else if operator == "=="
        comparison := source1 == source2
    else if operator == "!="
        comparison := source1 != source2
    else if operator == "crossover"
        comparison := ta.crossover(source1, source2)
    else if operator == "crossunder"
        comparison := ta.crossunder(source1, source2)
    else if operator == "isrising"
        comparison := ta.change(source1) > 0
    else if operator == "isfalling"
        comparison := ta.change(source1) < 0
    comparison
    
// Determine sources for comparison #1
longTargetSource1 = longTarget1 == "First Indicator" ? Source1_1 : (longTarget1 == "Second Indicator" ? Source2_1 : fixedLevelLong1)
shortTargetSource1 = shortTarget1 == "First Indicator" ? Source1_1 : (shortTarget1 == "Second Indicator" ? Source2_1 : fixedLevelShort1)

// Perform comparisons for Long and Short trades for comparison #1
longComparison1 = f_compare(longSource1, longTargetSource1, longOperator1)
shortComparison1 = f_compare(shortSource1, shortTargetSource1, shortOperator1)

// Determine sources for comparison #2
longTargetSource2 = longTarget2 == "First Indicator" ? Source1_2 : (longTarget2 == "Second Indicator" ? Source2_2 : fixedLevelLong2)
shortTargetSource2 = shortTarget2 == "First Indicator" ? Source1_2 : (shortTarget2 == "Second Indicator" ? Source2_2 : fixedLevelShort2)

// Perform comparisons for Long and Short trades for comparison #2
longComparison2 = f_compare(longSource2, longTargetSource2, longOperator2)
shortComparison2 = f_compare(shortSource2, shortTargetSource2, shortOperator2)

// ----------------------
// Filter Conditions Combination
// ----------------------
// Reset filters each bar
var bool filterLongCondition = true
var bool filterShortCondition = true

// Reset to default values at the beginning of each bar
filterLongCondition := true
filterShortCondition := true

// Range Filter
if useRangeFilter
    filterLongCondition := filterLongCondition and rangeFilterCondition
    filterShortCondition := filterShortCondition and rangeFilterCondition

// Volume Flow Filter
if enableVolumeFlow
    filterLongCondition := filterLongCondition and volumeFlowLongCondition
    filterShortCondition := filterShortCondition and volumeFlowShortCondition

// ADX Filter
if enableADX
    filterLongCondition := filterLongCondition and adxLongCondition
    filterShortCondition := filterShortCondition and adxShortCondition

// TDFI Filter
if enableTDFI
    filterLongCondition := filterLongCondition and tdfiLongCondition
    filterShortCondition := filterShortCondition and tdfiShortCondition

// Flat Market Filter
if enableFlatMarket
    filterLongCondition := filterLongCondition and flatMarketCondition
    filterShortCondition := filterShortCondition and flatMarketCondition

// Hurst Exponent Filter
if enableHurst
    filterLongCondition := filterLongCondition and hurstCondition
    filterShortCondition := filterShortCondition and hurstCondition

// Bull Bear Power Filter
if enableBullBear
    filterLongCondition := filterLongCondition and bullBearLongCondition
    filterShortCondition := filterShortCondition and bullBearShortCondition

// VWAP Crossover Filter
if useVWAPEMA
    filterLongCondition := filterLongCondition and vwapLongCondition
    filterShortCondition := filterShortCondition and vwapShortCondition

// Planetary Hours Filter
if usePlanetaryFilter
    planet_long_score = isPlanetHour(longPlanet) ? 1.0 : (1.0 / planetaryStrictness)
    planet_short_score = isPlanetHour(shortPlanet) ? 1.0 : (1.0 / planetaryStrictness)
    planetaryLongCondition := planet_long_score >= 1.0
    planetaryShortCondition := planet_short_score >= 1.0
    
    filterLongCondition := filterLongCondition and planetaryLongCondition
    filterShortCondition := filterShortCondition and planetaryShortCondition

//External Comparison 1 Filter
if ActivateExternalComparison1
    filterLongCondition := filterLongCondition and longComparison1
    filterShortCondition := filterShortCondition and shortComparison1

//External Comparison 2 Filter
if ActivateExternalComparison2
    filterLongCondition := filterLongCondition and longComparison2
    filterShortCondition := filterShortCondition and shortComparison2

// Update base conditions with filters
longCondition := longCondition and filterLongCondition
shortCondition := shortCondition and filterShortCondition

// Alert message JSON variables for strategy entry/exit
var string alert_message_entry_long = ""
var string alert_message_entry_short = ""
var string alert_message_exit_long = ""
var string alert_message_exit_short = ""
var string alert_message_tp1_long = ""
var string alert_message_tp2_long = ""
var string alert_message_tp3_long = ""
var string alert_message_tp1_short = ""
var string alert_message_tp2_short = ""
var string alert_message_tp3_short = ""

// Function to create JSON alert message
generateAlertJson(string action, float qty, float price, float tp, float sl, bool isLong) =>
    string position_val = action == "buy" ? (strategy.position_size < 0 ? "5" : "0") : (strategy.position_size > 0 ? "0" : "5")
    string jsonMsg = "{\n" + "\"action\": \"" + action + "\",\n" + "\"coin_pair\": \"" + syminfo.ticker + "\",\n" + "\"api_key\": \"" + apiKey + "\",\n" + "\"secret_key\": \"" + secretKey + "\",\n" + "\"position\": \"" + position_val + "\",\n" + "\"price\": \"" + str.tostring(price, "#.#####") + "\",\n" + "\"qty_in_percentage\": \"0\",\n" + "\"qty\": \"" + str.tostring(qty, "#.#####") + "\",\n"
    
    if useMultiTP
        jsonMsg := jsonMsg + "\"enable_multi_tp\": \"1\",\n" +
                           "\"tp_3_size\": \"100\",\n" +
                           "\"tp_3_price\": \"" + str.tostring(isLong ? tp3Long : tp3Short, "#.#####") + "\",\n"
    else
        jsonMsg := jsonMsg + "\"enable_multi_tp\": \"0\",\n" +
                           "\"tp_3_size\": \"100\",\n" +
                           "\"tp_3_price\": \"" + str.tostring(tp, "#.#####") + "\",\n"
    
    if not stopLossDisabled and not na(sl)
        jsonMsg := jsonMsg + "\"stop_loss_price\": \"" + str.tostring(sl, "#.#####") + "\",\n"
    
    jsonMsg := jsonMsg + "\"buy_leverage\": \"" + str.tostring(userLeverage) + "\",\n" +
                       "\"sell_leverage\": \"" + str.tostring(userLeverage) + "\",\n" +
                       "\"leverage\": \"" + str.tostring(userLeverage) + "\",\n" +
                       "\"use_testnet\": \"" + (apiTestnet ? "1" : "0") + "\",\n" +
                       "\"margin_mode\": \"" + (marginMode == "Cross" ? "0" : "1") + "\",\n" +
                       "\"order_type\": \"" + (action == "buy" ? (strategy.position_size < 0 ? "reduce_short" : "enter_long") : (strategy.position_size > 0 ? "reduce_long" : "enter_short")) + "\",\n" +
                       "\"simplified\": \"1\",\n" +
                       "\"unified\": \"1\",\n" +
                       "\"encryptor\": \"1\"\n"
    
    if telegramChannelID != ""
        jsonMsg := jsonMsg + ",\"telegram_channel_id\": \"" + telegramChannelID + "\"\n"
    
    jsonMsg := jsonMsg + "}"
    jsonMsg

// ----------------------
// Entry Logic with Pre-Entry Checks
// ----------------------
if bar_index > lastEntryBarIndex
    waitForNewBarEntry := false

// Reset waitForNewBarExit at the beginning of each new bar
if bar_index > lastExitBarIndex
    waitForNewBarExit := false

// Check for end of session exits
if useSessions and isEndOfSession() and tradeActive
    // Apply bar confirmation check here too
    bool canCloseOnSessionEnd = waitForBarConfirmation ? barstate.isconfirmed : true
    
    if canCloseOnSessionEnd
        if isLong and strategy.position_size > 0
            alert_message_exit_long := useMinimalistBot ? generateAlertJson("sell", strategy.position_size, close, 0, 0, true) : i_alert_txt_exit_long 
            strategy.close("Long", comment="End of Session", alert_message=alert_message_exit_long)
            tradeActive := false
            lastExitBarIndex := bar_index
            waitForNewBarExit := true
            currentPosition := "flat"
        else if not isLong and strategy.position_size < 0
            alert_message_exit_short := useMinimalistBot ? generateAlertJson("buy", math.abs(strategy.position_size), close, 0, 0, false) : i_alert_txt_exit_short
            strategy.close("Short", comment="End of Session", alert_message=alert_message_exit_short)
            tradeActive := false
            lastExitBarIndex := bar_index
            waitForNewBarExit := true
            currentPosition := "flat"

// Bar confirmation logic - only proceed with signal execution if this condition is met
bool canExecuteSignal = waitForBarConfirmation ? barstate.isconfirmed : true

// REVERSAL MODE - Check if we need to perform a reversal (regardless of position size)
// This ensures we check for reversal signals on every bar when reversal mode is enabled
if reversalMode and canExecuteSignal and not waitForNewBarEntry
    // Check for long signal while in short position
    if longTrades and longCondition and strategy.position_size < 0
        // Cancel any pending orders first
        strategy.cancel_all()
        
        // Close the existing short position
        alert_message_exit_short := useMinimalistBot ? generateAlertJson("buy", math.abs(strategy.position_size), close, 0, 0, false) : i_alert_txt_exit_short
        strategy.close("Short", comment="Reversal to Long", alert_message=alert_message_exit_short)
        
        // Open a new long position
        alert_message_entry_long := useMinimalistBot ? generateAlertJson("buy", roundedQty, close, tpLong, slLong, true) : i_alert_txt_entry_long 
        strategy.entry("Long", strategy.long, qty=roundedQty, alert_message=alert_message_entry_long)
        lastEntryCandle := bar_index
        lastEntryBarIndex := bar_index
        waitForNewBarEntry := true
        tradeActive := true
        isLong := true
        entryPrice := close
        entrySL := slLong
        entryTP := tpLong
        currentPosition := "long"
        
        // Update trade counters
        longTradesCount := 1
        shortTradesCount := 0
        lastTradeDirection := 1
        
        // Set up exit conditions
        if useMultiTP
            // Configure TP levels for long position
            tp1Price := tp1Long
            tp2Price := tp2Long
            tp3Price := tp3Long
            tp1Reached := false
            tp2Reached := false
            tp3Reached := false
        else if not stopLossDisabled
            if takeProfitType != "None"
                alert_message_exit_long := useMinimalistBot ? generateAlertJson("sell", strategy.position_size, close, entryTP, entrySL, true) : i_alert_txt_exit_long 
                strategy.exit("Exit Long", "Long", stop=entrySL, limit=entryTP, alert_message=alert_message_exit_long)
            else
                alert_message_exit_long := useMinimalistBot ? generateAlertJson("sell", strategy.position_size, close, 0, entrySL, true) : i_alert_txt_exit_long
                strategy.exit("SL Long", "Long", stop=entrySL, alert_message=alert_message_exit_long)
    
    // Check for short signal while in long position
    else if shortTrades and shortCondition and strategy.position_size > 0
        // Cancel any pending orders first
        strategy.cancel_all()
        
        // Close the existing long position
        alert_message_exit_long := useMinimalistBot ? generateAlertJson("sell", strategy.position_size, close, 0, 0, true) : i_alert_txt_exit_long 
        strategy.close("Long", comment="Reversal to Short", alert_message=alert_message_exit_long)
        
        // Open a new short position
        alert_message_entry_short := useMinimalistBot ? generateAlertJson("sell", roundedQty, close, tpShort, slShort, false) : i_alert_txt_entry_short 
        strategy.entry("Short", strategy.short, qty=roundedQty, alert_message=alert_message_entry_short)
        lastEntryCandle := bar_index
        lastEntryBarIndex := bar_index
        waitForNewBarEntry := true
        tradeActive := true
        isLong := false
        entryPrice := close
        entrySL := slShort
        entryTP := tpShort
        currentPosition := "short"
        
        // Update trade counters
        shortTradesCount := 1
        longTradesCount := 0
        lastTradeDirection := -1
        
        // Set up exit conditions
        if useMultiTP
            // Configure TP levels for short position
            tp1Price := tp1Short
            tp2Price := tp2Short
            tp3Price := tp3Short
            tp1Reached := false
            tp2Reached := false
            tp3Reached := false
        else if not stopLossDisabled
            if takeProfitType != "None"
                alert_message_exit_short := useMinimalistBot ? generateAlertJson("buy", math.abs(strategy.position_size), close, entryTP, entrySL, false) : i_alert_txt_exit_short
                strategy.exit("Exit Short", "Short", stop=entrySL, limit=entryTP, alert_message=alert_message_exit_short)
            else
                alert_message_exit_short := useMinimalistBot ? generateAlertJson("buy", math.abs(strategy.position_size), close, 0, entrySL, false) : i_alert_txt_exit_short
                strategy.exit("SL Short", "Short", stop=entrySL, alert_message=alert_message_exit_short)

// Normal entry logic (for new positions)
if strategy.position_size == 0 and not waitForNewBarEntry

    // Add session validation
    bool validSessionEntry = not useSessions or isInTradingSession()

    // Add this to your existing validations
    validEntry := validEntry and validSessionEntry

    // Add Trendilio protection to prevent entry right after exit
    bool validTrendilioEntry = true
    if useTrendilio and (trendilioTradeType == "OS/OB reverse" or trendilioTradeType == "OS/OB enter reverse" or trendilioTradeType == "OS/OB reverse exit")
        // Prevent entry on the same bar as previous exit
        validTrendilioEntry := bar_index > lastTrendilioExitBar
    
    // Add this check to your existing validEntry checks
    validEntry := validEntry and validTrendilioEntry
    
    // Pre-calculate potential SL and TP for validation
    if longTrades and longCondition
        // Check for leverage risk
        if i_leverageBlock
            validLongEntry := slLong > firstLeverageLongAverage
        
        // Check for minimum TP threshold
        if activateMinTP
            float tpPct = math.abs(tpLong - close) / close * 100
            if tpPct < minTPThreshold
                if minTPAction == "Use Percentage Instead"
                    // Update TP to use minimum percentage instead
                    tpLong := close * (1 + minTPThreshold / 100)
                    validLongEntry := true
                else
                    validLongEntry := false
                    
        // Check for maximum SL threshold
        if activateMaxSL
            float slPct = math.abs(close - slLong) / close * 100
            if slPct > maxSLThreshold
                if maxSLAction == "Use Percentage Instead"
                    // Update SL to use maximum percentage
                    slLong := close * (1 - maxSLThreshold / 100)
                    validLongEntry := true
                else
                    validLongEntry := false
                    
    else if shortTrades and shortCondition
        // Check for leverage risk
        if i_leverageBlock
            validShortEntry := slShort < firstLeverageShortAverage
        
        // Check for minimum TP threshold
        if activateMinTP
            float tpPct = math.abs(close - tpShort) / close * 100
            if tpPct < minTPThreshold
                if minTPAction == "Use Percentage Instead"
                    // Update TP to use minimum percentage instead
                    tpShort := close * (1 - minTPThreshold / 100)
                    validShortEntry := true
                else
                    validShortEntry := false
                    
        // Check for maximum SL threshold
        if activateMaxSL
            float slPct = math.abs(slShort - close) / close * 100
            if slPct > maxSLThreshold
                if maxSLAction == "Use Percentage Instead"
                    // Update SL to use maximum percentage
                    slShort := close * (1 + maxSLThreshold / 100)
                    validShortEntry := true
                else
                    validShortEntry := false
    
    // Final validation and entry execution (for new positions)
    if validEntry and canExecuteSignal
        // Long entry when we're flat
        if longTrades and longCondition and validLongEntry and roundedQty > 0
            alert_message_entry_long := useMinimalistBot ? generateAlertJson("buy", roundedQty, close, tpLong, slLong, true) : i_alert_txt_entry_long
            strategy.entry("Long", strategy.long, qty=roundedQty, alert_message=alert_message_entry_long)
            lastEntryCandle := bar_index
            lastEntryBarIndex := bar_index
            waitForNewBarEntry := true
            tradeActive := true
            isLong := true
            entryPrice := close
            entrySL := slLong
            entryTP := tpLong
            currentPosition := "long"
            
            // Update trade counters
            if lastTradeDirection == 1
                // Another long trade - increment count
                longTradesCount := longTradesCount + 1
            else
                // Direction change or first trade - reset counter
                longTradesCount := 1
                shortTradesCount := 0
            
            lastTradeDirection := 1
        
            if useMultiTP
                // Use pre-calculated TP levels
                tp1Price := tp1Long
                tp2Price := tp2Long
                tp3Price := tp3Long
    
                tp1Reached := false
                tp2Reached := false
                tp3Reached := false
            else
                // For regular exit with TP/SL
                if stopLossType == "None"
                    stopLossDisabled := true
                    if takeProfitType != "None"
                        // Only use take profit
                        alert_message_exit_long := useMinimalistBot ? generateAlertJson("sell", strategy.position_size, close, tpLong, 0, true) : i_alert_txt_exit_long 
                        strategy.exit("TP Long", "Long", limit=tpLong, alert_message=alert_message_exit_long)
                else
                    stopLossDisabled := false
                    // Use both SL and TP
                    if not stopLossDisabled
                        if takeProfitType != "None"
                            alert_message_exit_long := useMinimalistBot ? generateAlertJson("sell", strategy.position_size, close, entryTP, entrySL, true) : i_alert_txt_exit_long 
                            strategy.exit("Exit Long", "Long", stop=entrySL, limit=entryTP, alert_message=alert_message_exit_long)
                        else
                            alert_message_exit_long := useMinimalistBot ? generateAlertJson("sell", strategy.position_size, close, 0, entrySL, true) : i_alert_txt_exit_long 
                            strategy.exit("SL Long", "Long", stop=entrySL, alert_message=alert_message_exit_long)
            
        // Short entry when we're flat
        else if shortTrades and shortCondition and validShortEntry and roundedQty > 0
            alert_message_entry_short := useMinimalistBot ? generateAlertJson("sell", roundedQty, close, tpShort, slShort, false) : i_alert_txt_entry_short
            strategy.entry("Short", strategy.short, qty=roundedQty, alert_message=alert_message_entry_short)
            lastEntryCandle := bar_index
            lastEntryBarIndex := bar_index
            waitForNewBarEntry := true
            tradeActive := true
            isLong := false
            entryPrice := close
            entrySL := slShort
            entryTP := tpShort
            currentPosition := "short"
            
            // Update trade counters
            if lastTradeDirection == -1
                // Another short trade - increment count
                shortTradesCount := shortTradesCount + 1
            else
                // Direction change or first trade - reset counter
                shortTradesCount := 1
                longTradesCount := 0
            
            lastTradeDirection := -1
        
            if useMultiTP
                // Use pre-calculated TP levels
                tp1Price := tp1Short
                tp2Price := tp2Short
                tp3Price := tp3Short
    
                tp1Reached := false
                tp2Reached := false
                tp3Reached := false
            else
                // For regular exit with TP/SL
                if stopLossType == "None"
                    stopLossDisabled := true
                    if takeProfitType != "None"
                        // Only use take profit
                        alert_message_exit_short := useMinimalistBot ? generateAlertJson("buy", math.abs(strategy.position_size), close, tpShort, 0, false) : i_alert_txt_exit_short
                        strategy.exit("TP Short", "Short", limit=tpShort, alert_message=alert_message_exit_short)
                else
                    stopLossDisabled := false
                    // Use both SL and TP
                    if not stopLossDisabled
                        if takeProfitType != "None"
                            alert_message_exit_short := useMinimalistBot ? generateAlertJson("buy", math.abs(strategy.position_size), close, entryTP, entrySL, false) : i_alert_txt_exit_short
                            strategy.exit("Exit Short", "Short", stop=entrySL, limit=entryTP, alert_message=alert_message_exit_short)
                        else
                            alert_message_exit_short := useMinimalistBot ? generateAlertJson("buy", math.abs(strategy.position_size), close, 0, entrySL, false) : i_alert_txt_exit_short
                            strategy.exit("SL Short", "Short", stop=entrySL, alert_message=alert_message_exit_short)
    else
        strategy.cancel("Long")
        strategy.cancel("Short")

// ----------------------
// Exit Logic (Immediate)
// ----------------------
if tradeActive and bar_index > lastEntryCandle + 1 and not waitForNewBarExit
    // Apply bar confirmation check to exits
    bool canExitSignal = waitForBarConfirmation ? barstate.isconfirmed : true
    
    if canExitSignal
        // Only check for normal exits if we're not in reversal mode or there's no reversal signal
        bool skipNormalExits = false
        if reversalMode
            if isLong and strategy.position_size > 0 and shortCondition
                skipNormalExits := true  // Skip normal exits, let the reversal logic handle it
            else if not isLong and strategy.position_size < 0 and longCondition
                skipNormalExits := true  // Skip normal exits, let the reversal logic handle it
        
        if not skipNormalExits
            // Force exit logic
            if force_exit
                if isLong and strategy.position_size > 0 and not longCondition
                    alert_message_exit_long := useMinimalistBot ? generateAlertJson("sell", strategy.position_size, close, 0, 0, true) : i_alert_txt_exit_long 
                    strategy.close("Long", comment="Forced Exit Long", alert_message=alert_message_exit_long)
                    tradeActive := false
                    lastTrendilioExitBar := bar_index
                    lastExitBarIndex := bar_index
                    waitForNewBarExit := true
                    currentPosition := "flat"
                else if not isLong and strategy.position_size < 0 and not shortCondition
                    alert_message_exit_short := useMinimalistBot ? generateAlertJson("buy", math.abs(strategy.position_size), close, 0, 0, false) : i_alert_txt_exit_short
                    strategy.close("Short", comment="Forced Exit Short", alert_message=alert_message_exit_short)
                    tradeActive := false
                    lastTrendilioExitBar := bar_index
                    lastExitBarIndex := bar_index
                    waitForNewBarExit := true
                    currentPosition := "flat"
            
            // Normal SL/TP exits - only process if not using Multi TP
            if not useMultiTP
                if strategy.position_size > 0
                    if not stopLossDisabled and not na(entrySL) and low <= entrySL and bar_index != lastExitBarIndex
                        alert_message_exit_long := useMinimalistBot ? generateAlertJson("sell", strategy.position_size, close, 0, 0, true) : i_alert_txt_exit_long 
                        strategy.close("Long", comment="Stop Loss", alert_message=alert_message_exit_long)
                        tradeActive := false
                        lastTrendilioExitBar := bar_index
                        lastExitBarIndex := bar_index
                        waitForNewBarExit := true
                        currentPosition := "flat"
                    else if takeProfitType != "None" and not na(entryTP) and high >= entryTP and close > entryPrice and bar_index != lastExitBarIndex
                        alert_message_exit_long := useMinimalistBot ? generateAlertJson("sell", strategy.position_size, close, 0, 0, true) : i_alert_txt_exit_long 
                        strategy.close("Long", comment="Take Profit", alert_message=alert_message_exit_long)
                        tradeActive := false
                        lastTrendilioExitBar := bar_index
                        lastExitBarIndex := bar_index
                        waitForNewBarExit := true
                        currentPosition := "flat"
                else if strategy.position_size < 0
                    if not stopLossDisabled and not na(entrySL) and high >= entrySL and bar_index != lastExitBarIndex
                        alert_message_exit_short := useMinimalistBot ? generateAlertJson("buy", math.abs(strategy.position_size), close, 0, 0, false) : i_alert_txt_exit_short
                        strategy.close("Short", comment="Stop Loss", alert_message=alert_message_exit_short)
                        tradeActive := false
                        lastTrendilioExitBar := bar_index
                        lastExitBarIndex := bar_index
                        waitForNewBarExit := true
                        currentPosition := "flat"
                    else if takeProfitType != "None" and not na(entryTP) and low <= entryTP and close < entryPrice and bar_index != lastExitBarIndex
                        alert_message_exit_short := useMinimalistBot ? generateAlertJson("buy", math.abs(strategy.position_size), close, 0, 0, false) : i_alert_txt_exit_short
                        strategy.close("Short", comment="Take Profit", alert_message=alert_message_exit_short)
                        tradeActive := false
                        lastTrendilioExitBar := bar_index
                        lastExitBarIndex := bar_index
                        waitForNewBarExit := true
                        currentPosition := "flat"
                        
            // Planetary Force Exit Logic
            if useForceExit and usePlanetaryFilter and tradeActive and bar_index > lastEntryCandle + forceExitWaitBars
                // Force exit long position during selected planet hour
                if isLong and strategy.position_size > 0 and forceExitLongPlanet != "None" and isPlanetHour(forceExitLongPlanet) and bar_index != lastExitBarIndex
                    alert_message_exit_long := useMinimalistBot ? generateAlertJson("sell", strategy.position_size, close, 0, 0, true) : i_alert_txt_exit_long 
                    strategy.close("Long", comment="Force Exit - " + forceExitLongPlanet, alert_message=alert_message_exit_long)
                    tradeActive := false
                    lastTrendilioExitBar := bar_index
                    lastExitBarIndex := bar_index
                    waitForNewBarExit := true
                    currentPosition := "flat"
                
                // Force exit short position during selected planet hour
                if not isLong and strategy.position_size < 0 and forceExitShortPlanet != "None" and isPlanetHour(forceExitShortPlanet) and bar_index != lastExitBarIndex
                    alert_message_exit_short := useMinimalistBot ? generateAlertJson("buy", math.abs(strategy.position_size), close, 0, 0, false) : i_alert_txt_exit_short
                    strategy.close("Short", comment="Force Exit - " + forceExitShortPlanet, alert_message=alert_message_exit_short)
                    tradeActive := false
                    lastTrendilioExitBar := bar_index
                    lastExitBarIndex := bar_index
                    waitForNewBarExit := true
                    currentPosition := "flat"

// ----------------------
// Early Exit Protection Check
// ----------------------
if earlyExitProtection and tradeActive and bar_index > lastEntryCandle + 1 and not waitForNewBarExit
    // Apply bar confirmation check to early exits
    bool canExitEarly = waitForBarConfirmation ? barstate.isconfirmed : true
    
    // Skip early exits if we're in reversal mode with opposite signal
    bool skipEarlyExits = false
    if reversalMode
        if isLong and strategy.position_size > 0 and shortCondition
            skipEarlyExits := true  // Skip early exits, let the reversal logic handle it
        else if not isLong and strategy.position_size < 0 and longCondition
            skipEarlyExits := true  // Skip early exits, let the reversal logic handle it
    
    if canExitEarly and not skipEarlyExits and not stopLossDisabled  // Only apply if SL is active
        if isLong and strategy.position_size > 0 and close < earlyExitMA and bar_index != lastExitBarIndex
            alert_message_exit_long := useMinimalistBot ? generateAlertJson("sell", strategy.position_size, close, 0, 0, true) : i_alert_txt_exit_long 
            strategy.close("Long", comment="Early Exit Protection", immediately=false, alert_message=alert_message_exit_long)
            tradeActive := false
            lastTrendilioExitBar := bar_index
            lastExitBarIndex := bar_index
            waitForNewBarExit := true
            currentPosition := "flat"
        else if not isLong and strategy.position_size < 0 and close > earlyExitMA and bar_index != lastExitBarIndex
            alert_message_exit_short := useMinimalistBot ? generateAlertJson("buy", math.abs(strategy.position_size), close, 0, 0, false) : i_alert_txt_exit_short
            strategy.close("Short", comment="Early Exit Protection", immediately=false, alert_message=alert_message_exit_short)
            tradeActive := false
            lastTrendilioExitBar := bar_index
            lastExitBarIndex := bar_index
            waitForNewBarExit := true
            currentPosition := "flat"

// ----------------------
// Multi Take Profit Execution Logic
// ----------------------
if useMultiTP and tradeActive and bar_index > lastEntryCandle
    // Apply bar confirmation check to multi-TPs
    bool canTriggerTP = waitForBarConfirmation ? barstate.isconfirmed : true
    
    // Skip take profits if we're in reversal mode with opposite signal
    bool skipTP = false
    if reversalMode
        if isLong and strategy.position_size > 0 and shortCondition
            skipTP := true  // Skip take profits, let the reversal logic handle it
        else if not isLong and strategy.position_size < 0 and longCondition
            skipTP := true  // Skip take profits, let the reversal logic handle it
    
    if canTriggerTP and not skipTP
        // Check for stop loss first
        if isLong and strategy.position_size > 0
            // Check if stop loss is hit
            if not stopLossDisabled and not na(entrySL) and low <= entrySL and bar_index != lastExitBarIndex
                alert_message_exit_long := useMinimalistBot ? generateAlertJson("sell", strategy.position_size, close, 0, 0, true) : i_alert_txt_exit_long 
                strategy.close("Long", comment="Stop Loss", alert_message=alert_message_exit_long)
                tradeActive := false
                lastTrendilioExitBar := bar_index
                lastExitBarIndex := bar_index
                waitForNewBarExit := true
                currentPosition := "flat"
            else
                // Only process take profits if stop loss is not hit
                // Ensure we don't process multiple TPs in the same bar
                if tp1Enabled and not tp1Reached and high >= tp1Price and bar_index != lastExitBarIndex
                    float closeAmount = roundedQty * (tp1Percent / 100)
                    closeAmount := f_round_qty(closeAmount)
                    closeAmount := math.max(closeAmount, 0.01)
                    if closeAmount > 0
                        alert_message_tp1_long := useMinimalistBot ? generateAlertJson("sell", closeAmount, tp1Price, 0, 0, true) : i_alert_txt_tp1_long
                        strategy.order("TP1 Hit", strategy.short, qty=closeAmount, alert_message=alert_message_tp1_long)
                        tp1Reached := true
                        lastExitBarIndex := bar_index
                        waitForNewBarExit := true
                
                if tp2Enabled and not tp2Reached and high >= tp2Price and bar_index != lastExitBarIndex
                    float closeAmount = roundedQty * (tp2Percent / 100)
                    closeAmount := f_round_qty(closeAmount)
                    closeAmount := math.max(closeAmount, 0.01)
                    if closeAmount > 0
                        alert_message_tp2_long := useMinimalistBot ? generateAlertJson("sell", closeAmount, tp2Price, 0, 0, true) : i_alert_txt_tp2_long
                        strategy.order("TP2 Hit", strategy.short, qty=closeAmount, alert_message=alert_message_tp2_long)
                        tp2Reached := true
                        lastExitBarIndex := bar_index
                        waitForNewBarExit := true
                
                if not tp3Reached and high >= tp3Price and bar_index != lastExitBarIndex
                    alert_message_tp3_long := useMinimalistBot ? generateAlertJson("sell", strategy.position_size, tp3Price, 0, 0, true) : i_alert_txt_tp3_long
                    strategy.close("Long", comment="TP3 Hit", alert_message=alert_message_tp3_long)
                    tp3Reached := true
                    tradeActive := false
                    lastTrendilioExitBar := bar_index
                    lastExitBarIndex := bar_index
                    waitForNewBarExit := true
                    currentPosition := "flat"
        
        else if not isLong and strategy.position_size < 0
            // Check if stop loss is hit
            if not stopLossDisabled and not na(entrySL) and high >= entrySL and bar_index != lastExitBarIndex
                alert_message_exit_short := useMinimalistBot ? generateAlertJson("buy", math.abs(strategy.position_size), close, 0, 0, false) : i_alert_txt_exit_short
                strategy.close("Short", comment="Stop Loss", alert_message=alert_message_exit_short)
                tradeActive := false
                lastTrendilioExitBar := bar_index
                lastExitBarIndex := bar_index
                waitForNewBarExit := true
                currentPosition := "flat"
            else
                // Only process take profits if stop loss is not hit
                // Ensure we don't process multiple TPs in the same bar
                if tp1Enabled and not tp1Reached and low <= tp1Price and bar_index != lastExitBarIndex
                    float closeAmount = roundedQty * (tp1Percent / 100)
                    closeAmount := f_round_qty(closeAmount)
                    closeAmount := math.max(closeAmount, 0.01)
                    if closeAmount > 0
                        alert_message_tp1_short := useMinimalistBot ? generateAlertJson("buy", closeAmount, tp1Price, 0, 0, false) : i_alert_txt_tp1_short 
                        strategy.order("TP1 Hit", strategy.long, qty=closeAmount, alert_message=alert_message_tp1_short)
                        tp1Reached := true
                        lastExitBarIndex := bar_index
                        waitForNewBarExit := true
                
                if tp2Enabled and not tp2Reached and low <= tp2Price and bar_index != lastExitBarIndex
                    float closeAmount = roundedQty * (tp2Percent / 100)
                    closeAmount := f_round_qty(closeAmount)
                    closeAmount := math.max(closeAmount, 0.01)
                    if closeAmount > 0
                        alert_message_tp2_short := useMinimalistBot ? generateAlertJson("buy", closeAmount, tp2Price, 0, 0, false) : i_alert_txt_tp2_short 
                        strategy.order("TP2 Hit", strategy.long, qty=closeAmount, alert_message=alert_message_tp2_short)
                        tp2Reached := true
                        lastExitBarIndex := bar_index
                        waitForNewBarExit := true
                
                if not tp3Reached and low <= tp3Price and bar_index != lastExitBarIndex
                    alert_message_tp3_short := useMinimalistBot ? generateAlertJson("buy", math.abs(strategy.position_size), tp3Price, 0, 0, false) : i_alert_txt_tp3_short 
                    strategy.close("Short", comment="TP3 Hit", alert_message=alert_message_tp3_short)
                    tp3Reached := true
                    tradeActive := false
                    lastTrendilioExitBar := bar_index
                    lastExitBarIndex := bar_index
                    waitForNewBarExit := true
                    currentPosition := "flat"
                
// ----------------------
// Improved Trendilio-Specific Exits
// ----------------------
if tradeActive and bar_index > lastEntryCandle + 1 and not waitForNewBarExit and useTrendilio
    // Apply bar confirmation check to Trendilio exits
    bool canExitTrendilio = waitForBarConfirmation ? barstate.isconfirmed : true
    
    // Skip Trendilio exits if we're in reversal mode with opposite signal
    bool skipTrendilioExit = false
    if reversalMode
        if isLong and strategy.position_size > 0 and shortCondition
            skipTrendilioExit := true  // Skip Trendilio exits, let the reversal logic handle it
        else if not isLong and strategy.position_size < 0 and longCondition
            skipTrendilioExit := true  // Skip Trendilio exits, let the reversal logic handle it
    
    if canExitTrendilio and not skipTrendilioExit
        if trendilioTradeType == "OS/OB exit"
            if isLong and strategy.position_size > 0 and exitOS and bar_index != lastExitBarIndex
                alert_message_exit_long := useMinimalistBot ? generateAlertJson("sell", strategy.position_size, close, 0, 0, true) : i_alert_txt_exit_long 
                strategy.close("Long", comment="Trendilio Exit Mode", immediately=false, alert_message=alert_message_exit_long)
                tradeActive := false
                lastTrendilioExitBar := bar_index
                lastExitBarIndex := bar_index
                waitForNewBarExit := true
                currentPosition := "flat"
            else if not isLong and strategy.position_size < 0 and exitOB and bar_index != lastExitBarIndex
                alert_message_exit_short := useMinimalistBot ? generateAlertJson("buy", math.abs(strategy.position_size), close, 0, 0, false) : i_alert_txt_exit_short
                strategy.close("Short", comment="Trendilio Exit Mode", immediately=false, alert_message=alert_message_exit_short) 
                tradeActive := false
                lastTrendilioExitBar := bar_index
                lastExitBarIndex := bar_index
                waitForNewBarExit := true
                currentPosition := "flat"
        else if trendilioTradeType == "OS/OB reverse exit"
            if isLong and strategy.position_size > 0 and bar_index != lastExitBarIndex
                if exitOS or (smoothed_davpch < 0 and smoothed_davpch[1] < 0 and smoothed_davpch[2] < 0)
                    alert_message_exit_long := useMinimalistBot ? generateAlertJson("sell", strategy.position_size, close, 0, 0, true) : i_alert_txt_exit_long 
                    strategy.close("Long", comment="Trendilio Reverse Exit Mode", immediately=false, alert_message=alert_message_exit_long)
                    tradeActive := false
                    lastTrendilioExitBar := bar_index
                    lastExitBarIndex := bar_index
                    waitForNewBarExit := true
                    currentPosition := "flat"
            else if not isLong and strategy.position_size < 0 and bar_index != lastExitBarIndex
                if exitOB or (smoothed_davpch > 0 and smoothed_davpch[1] > 0 and smoothed_davpch[2] > 0)
                    alert_message_exit_short := useMinimalistBot ? generateAlertJson("buy", math.abs(strategy.position_size), close, 0, 0, false) : i_alert_txt_exit_short
                    strategy.close("Short", comment="Trendilio Reverse Exit Mode", immediately=false, alert_message=alert_message_exit_short)
                    tradeActive := false
                    lastTrendilioExitBar := bar_index
                    lastExitBarIndex := bar_index
                    waitForNewBarExit := true
                    currentPosition := "flat"
        else if trendilioTradeType == "OS/OB reverse"
            if isLong and strategy.position_size > 0 and bar_index != lastExitBarIndex
                if exitOS or (smoothed_davpch < 0 and smoothed_davpch[1] < 0 and smoothed_davpch[2] < 0)
                    alert_message_exit_long := useMinimalistBot ? generateAlertJson("sell", strategy.position_size, close, 0, 0, true) : i_alert_txt_exit_long 
                    strategy.close("Long", comment="Trendilio Reverse Mode", immediately=false, alert_message=alert_message_exit_long)
                    tradeActive := false
                    lastTrendilioExitBar := bar_index
                    lastExitBarIndex := bar_index
                    waitForNewBarExit := true
                    currentPosition := "flat"
            else if not isLong and strategy.position_size < 0 and bar_index != lastExitBarIndex
                if exitOB or (smoothed_davpch > 0 and smoothed_davpch[1] > 0 and smoothed_davpch[2] > 0)
                    alert_message_exit_short := useMinimalistBot ? generateAlertJson("buy", math.abs(strategy.position_size), close, 0, 0, false) : i_alert_txt_exit_short
                    strategy.close("Short", comment="Trendilio Reverse Mode", immediately=false, alert_message=alert_message_exit_short)
                    tradeActive := false
                    lastTrendilioExitBar := bar_index
                    lastExitBarIndex := bar_index
                    waitForNewBarExit := true
                    currentPosition := "flat"

// // ----------------------
// // Alert Variables and Helpers
// // ----------------------
// // Set up alert preferences based on your needs
// var bool useOnlyStrategyAlerts = true  // Set to true to use only built-in strategy alerts
// var bool allowOrderFillAlerts = true   // Always allow alerts from strategy operations
// var bool allowFunctionCallAlerts = not useOnlyStrategyAlerts  // Only allow custom alerts if not using strategy-only mode

// // Alert flag variables to prevent duplicate alerts
// var bool alertSent_entry_long = false
// var bool alertSent_entry_short = false
// var bool alertSent_exit_long = false
// var bool alertSent_exit_short = false
// var bool alertSent_tp1_long = false
// var bool alertSent_tp2_long = false
// var bool alertSent_tp3_long = false
// var bool alertSent_tp1_short = false
// var bool alertSent_tp2_short = false
// var bool alertSent_tp3_short = false
// var bool alertSent_custom_indicator1 = false
// var bool alertSent_custom_indicator2 = false
// var bool alertSent_custom_indicator3 = false
// var bool alertSent_custom_indicator4 = false

// // Reset alert flags on new bar (not on close - this is important)
// if barstate.isnew
//     alertSent_entry_long := false
//     alertSent_entry_short := false
//     alertSent_exit_long := false
//     alertSent_exit_short := false
//     alertSent_tp1_long := false
//     alertSent_tp2_long := false
//     alertSent_tp3_long := false
//     alertSent_tp1_short := false
//     alertSent_tp2_short := false
//     alertSent_tp3_short := false
//     alertSent_custom_indicator1 := false
//     alertSent_custom_indicator2 := false
//     alertSent_custom_indicator3 := false
//     alertSent_custom_indicator4 := false

// // Convert alert frequency string to alert frequency value
// getAlertFreq() =>
//     // Always default to once per bar (not on close) for instant alerts
//     alertFrequency == "Once per bar" ? alert.freq_once_per_bar : alertFrequency == "Once per close" ? alert.freq_once_per_bar_close : alertFrequency == "All" ? alert.freq_all : alert.freq_once_per_bar

// // Format alert message for Minimalist Bot Mode - completely rewritten for reliable JSON
// formatMinimalistBotMessage(string action, float qty, float price, string ticker) =>
//     // Make sure qty is never zero or empty - use a minimum value if needed
//     float safeQty = qty <= 0 ? 0.001 : qty
    
//     // Format JSON as a single line string without any breaks
//     string message = "{"
    
//     // Add common fields based on exchange format
//     if exchangeFormat == "MT5"
//         // MT5 format (single-line JSON for more reliable parsing)
//         message := message + "\"simplified\":\"1\",\"inverse\":\"0\",\"encryptor\":\"1\",\"unified\":\"0\",\"api_key\":\"" + apiKey + "\",\"accountnumber\":\"" + accountNumber + "\",\"passphrase\":\"ABCDEFG\",\"email_id\":\"" + emailId + "\",\"magic_number\":\"" + magicNumber + "\",\"round\":\"0\",\"round_inf\":\"1\""
//     else
//         // Crypto Exchange format (single-line JSON for more reliable parsing)
//         message := message + "\"simplified\":\"1\",\"inverse\":\"0\",\"encryptor\":\"1\",\"unified\":\"1\",\"api_key\":\"" + apiKey + "\",\"secret_key\":\"" + secretKey + "\",\"passphrase\":\"ABCDEFG\",\"email_id\":\"" + emailId + "\""
    
//     // Add trade-specific information with explicit quantity formatting
//     message := message + ",\"action\":\"" + action + "\""
//     message := message + ",\"qty\":\"" + str.tostring(safeQty, "#.#####") + "\""
//     message := message + ",\"position_size\":\"" + str.tostring(math.abs(strategy.position_size), "#.#####") + "\""
//     message := message + ",\"price\":\"" + str.tostring(price, "#.#####") + "\""
//     message := message + ",\"signal_param\":\"{}\",\"signal_type\":\"\",\"coin_pair\":\"" + ticker + "\""
//     message := message + ",\"time\":\"" + str.format("{0,number,00}-{1,number,00}-{2,number,00} {3,number,00}:{4,number,00}", year(time), month(time), dayofmonth(time), hour(time), minute(time)) + "\""
    
//     // Add optional safety parameters
//     if useSafetyTP
//         message := message + ",\"safety_tp\":\"1\""
    
//     if useSafetySL
//         message := message + ",\"safety_sl\":\"1\""
        
//     // Add Telegram channel ID if provided
//     if telegramChannelID != ""
//         message := message + ",\"telegram_channel_id\":\"" + telegramChannelID + "\""
        
//     // Add mandatory params for MinimalistBot
//     message := message + ",\"margin_mode\":\"1\",\"use_testnet\":\"0\",\"qty_in_percentage\":\"0\""
    
//     // Handle order type based on action and current position
//     if action == "buy"
//         // For buy actions
//         if strategy.position_size < 0
//             // Buying to close/reduce a short position
//             message := message + ",\"order_type\":\"reduce_short\",\"position\":\"5\""
//         else
//             // Buying to open a long position
//             message := message + ",\"order_type\":\"enter_long\",\"position\":\"0\""
//     else if action == "sell"
//         // For sell actions
//         if strategy.position_size > 0
//             // Selling to close/reduce a long position
//             message := message + ",\"order_type\":\"reduce_long\",\"position\":\"0\""
//         else
//             // Selling to open a short position
//             message := message + ",\"order_type\":\"enter_short\",\"position\":\"5\""
//     else
//         // Fallback for unexpected actions
//         message := message + ",\"order_type\":\"" + (action == "buy" ? "enter_long" : "enter_short") + "\",\"position\":\"" + (action == "buy" ? "0" : "5") + "\""
    
//     // Add leverage info
//     message := message + ",\"leverage\":\"" + str.tostring(userLeverage) + "\",\"sell_leverage\":\"" + str.tostring(userLeverage) + "\",\"buy_leverage\":\"" + str.tostring(userLeverage) + "\""
    
//     // Add multi-TP settings
//     message := message + ",\"enable_multi_tp\":\"" + (useMultiTP ? "1" : "0") + "\",\"pyramiding\":\"0\""
    
//     if useMultiTP
//         message := message + ",\"tp_type\":\"0\",\"multi_tp\":\"0\",\"tp_3_size\":\"100\",\"tp_3_price\":\"" + str.tostring(action == "buy" ? tp3Long : tp3Short, "#.#####") + "\""
    
//     // Add stop loss price if available
//     if not stopLossDisabled
//         message := message + ",\"stop_loss_price\":\"" + str.tostring(action == "buy" ? slLong : slShort, "#.#####") + "\""
    
//     // Close the JSON object
//     message := message + "}"
    
//     message

// // Format alert message with placeholders
// formatAlertMessage(string template, float qty, float entryPrice, float tp, float sl, string direction) =>
//     string message = template
    
//     // Basic order information
//     message := str.replace(message, "#pair#", syminfo.ticker)
//     message := str.replace(message, "#dir#", direction)
//     message := str.replace(message, "#side#", direction == "Buy" ? "Long" : "Short")
//     message := str.replace(message, "#qty#", str.tostring(f_round_qty(qty), "#.#####"))
//     message := str.replace(message, "#margin#", str.tostring(f_round_qty(qty), "#.#####"))
    
//     // Price information with additional precision
//     message := str.replace(message, "#price#", str.tostring(entryPrice, "#.#####"))
//     message := str.replace(message, "#entry#", str.tostring(entryPrice, "#.#####"))
//     message := str.replace(message, "#TP#", str.tostring(tp, "#.#####"))
//     message := str.replace(message, "#SL#", str.tostring(sl, "#.#####"))
    
//     // Risk and position information
//     message := str.replace(message, "#lev#", str.tostring(userLeverage, "#.##"))
//     message := str.replace(message, "#risk#", str.tostring(useFixedRiskPct ? 1.0 : risk, "#.##") + "%")
//     message := str.replace(message, "#riskUSD#", str.tostring(strategy.equity * ((useFixedRiskPct ? 1.0 : risk) / 100), "#.##"))
    
//     // Stop loss and take profit distances
//     float slDistPct = na(sl) or na(entryPrice) ? 0.0 : math.abs(sl - entryPrice) / entryPrice * 100
//     float tpDistPct = na(tp) or na(entryPrice) ? 0.0 : math.abs(tp - entryPrice) / entryPrice * 100
//     message := str.replace(message, "#SLdist#", str.tostring(slDistPct, "#.##") + "%")
//     message := str.replace(message, "#TPdist#", str.tostring(tpDistPct, "#.##") + "%")
    
//     // Account and position information
//     message := str.replace(message, "#acc#", str.tostring(strategy.equity, "#.##"))
//     message := str.replace(message, "#equity#", str.tostring(strategy.equity, "#.##"))
//     message := str.replace(message, "#pos#", str.tostring(math.abs(strategy.position_size), "#.#####"))
    
//     // Reward-to-risk ratio
//     float rrRatio = slDistPct > 0 ? tpDistPct / slDistPct : 0.0
//     message := str.replace(message, "#RR#", str.tostring(rrRatio, "#.##"))
    
//     // Current date/time placeholder
//     string dateStr = str.format("{0,number,00}-{1,number,00}-{2,number,00} {3,number,00}:{4,number,00}", year(time), month(time), dayofmonth(time), hour(time), minute(time))
//     message := str.replace(message, "#time#", dateStr)
    
//     // API connector specific placeholders
//     if useAPIConnection
//         message := str.replace(message, "#testnet#", apiTestnet ? "1" : "0")
//         message := str.replace(message, "#marginmode#", marginMode == "Cross" ? "0" : "1")
//         message := str.replace(message, "#entryordertype#", entryOrderType == "Market" ? "0" : "1")
//         message := str.replace(message, "#exitordertype#", exitOrderType == "Market" ? "0" : "1")
//         message := str.replace(message, "#timeout#", str.tostring(orderTimeout))
    
//     message

// // Function to trigger direct alerts - only used in MinimalistBot mode or when allowFunctionCallAlerts is true
// triggerAlert(string message) =>
//     if (barstate.isconfirmed or useImmediateAlerts) and (useMinimalistBot or allowFunctionCallAlerts)
//         alert(message, getAlertFreq())

// // Get appropriate template based on current settings
// getLongEntryTemplate() => useMinimalistBot ? formatMinimalistBotMessage("buy", roundedQty, close, syminfo.ticker) : (i_alert_txt_entry_long != "" ? i_alert_txt_entry_long : "Buy #pair# Q=#qty# Entry=#price# TP=#TP# SL=#SL# Lev=#lev# Risk=#risk# R:R=#RR#")

// getShortEntryTemplate() => useMinimalistBot ? formatMinimalistBotMessage("sell", roundedQty, close, syminfo.ticker) : (i_alert_txt_entry_short != "" ? i_alert_txt_entry_short : "Sell #pair# Q=#qty# Entry=#price# TP=#TP# SL=#SL# Lev=#lev# Risk=#risk# R:R=#RR#")

// getLongExitTemplate() => useMinimalistBot ? formatMinimalistBotMessage("sell", math.abs(strategy.position_size), close, syminfo.ticker) : (i_alert_txt_exit_long != "" ? i_alert_txt_exit_long : "Exit Long #pair# Q=#pos# Price=#price# PnL=#riskUSD#")

// getShortExitTemplate() => useMinimalistBot ? formatMinimalistBotMessage("buy", math.abs(strategy.position_size), close, syminfo.ticker) : (i_alert_txt_exit_short != "" ? i_alert_txt_exit_short : "Exit Short #pair# Q=#pos# Price=#price# PnL=#riskUSD#")

// // Get TP alert templates - simplified as one-liners
// getTP1LongTemplate() => useMinimalistBot ? formatMinimalistBotMessage("sell", roundedQty * (tp1Percent / 100), tp1Price, syminfo.ticker) : (i_alert_txt_tp1_long != "" ? i_alert_txt_tp1_long : "TP1 Long #pair# Q=#qty# Price=#TP# #time#")

// getTP2LongTemplate() => useMinimalistBot ? formatMinimalistBotMessage("sell", roundedQty * (tp2Percent / 100), tp2Price, syminfo.ticker) : (i_alert_txt_tp2_long != "" ? i_alert_txt_tp2_long : "TP2 Long #pair# Q=#qty# Price=#TP# #time#")

// getTP3LongTemplate() => useMinimalistBot ? formatMinimalistBotMessage("sell", strategy.position_size, tp3Price, syminfo.ticker) : (i_alert_txt_tp3_long != "" ? i_alert_txt_tp3_long : "TP3 Long #pair# Q=#qty# Price=#TP# #time#")

// getTP1ShortTemplate() => useMinimalistBot ? formatMinimalistBotMessage("buy", roundedQty * (tp1Percent / 100), tp1Price, syminfo.ticker) : (i_alert_txt_tp1_short != "" ? i_alert_txt_tp1_short : "TP1 Short #pair# Q=#qty# Price=#TP# #time#")

// getTP2ShortTemplate() => useMinimalistBot ? formatMinimalistBotMessage("buy", roundedQty * (tp2Percent / 100), tp2Price, syminfo.ticker) : (i_alert_txt_tp2_short != "" ? i_alert_txt_tp2_short : "TP2 Short #pair# Q=#qty# Price=#TP# #time#")

// getTP3ShortTemplate() => useMinimalistBot ? formatMinimalistBotMessage("buy", math.abs(strategy.position_size), tp3Price, syminfo.ticker) : (i_alert_txt_tp3_short != "" ? i_alert_txt_tp3_short : "TP3 Short #pair# Q=#qty# Price=#TP# #time#")

// // Custom indicator alert templates
// getCustomIndicator1Template() => "Custom Indicator #1: " + (longComparison1 ? "Long Signal" : "") + (shortComparison1 ? "Short Signal" : "") + " on #pair# at #time#"
// getCustomIndicator2Template() => "Custom Indicator #2: " + (longComparison2 ? "Long Signal" : "") + (shortComparison2 ? "Short Signal" : "") + " on #pair# at #time#"

// // ----------------------
// // Main Alert Implementation Logic
// // ----------------------
// // Only implement this if we're not in optimization mode
// if not optimizingTime
//     // Define exit conditions as one-liners for readability
//     // WAE and Trendilio exit conditions
//     bool bearishMomentumSignal = d_avpch < 0 and nz(d_avpch[1]) < 0 and nz(d_avpch[2]) < 0
//     bool bullishMomentumSignal = d_avpch > 0 and nz(d_avpch[1]) > 0 and nz(d_avpch[2]) > 0
    
//     // T3 exit conditions - specialized for this strategy
//     bool t3ExitLong = tradeActive and isLong and useT3 and t3Value < t3Value[1]
//     bool t3ExitShort = tradeActive and not isLong and useT3 and t3Value > t3Value[1]
    
//     // WAE exit conditions - specific to this strategy
//     bool waeExitLong = tradeActive and isLong and useWAE and (useExplosionLine ? t1 < -e1 : trendDown > noTradeZoneThreshold)
//     bool waeExitShort = tradeActive and not isLong and useWAE and (useExplosionLine ? t1 > e1 : trendUp > noTradeZoneThreshold)

//     // Trendilio exit conditionals
//     bool trendilioExitLong = tradeActive and isLong and useTrendilio and 
//                              ((trendilioTradeType == "OS/OB exit" and exitOS) or 
//                               (trendilioTradeType == "OS/OB reverse exit" and (exitOS or bearishMomentumSignal)) or 
//                               (trendilioTradeType == "OS/OB reverse" and (exitOS or bearishMomentumSignal)))
                              
//     bool trendilioExitShort = tradeActive and not isLong and useTrendilio and 
//                               ((trendilioTradeType == "OS/OB exit" and exitOB) or 
//                                (trendilioTradeType == "OS/OB reverse exit" and (exitOB or bullishMomentumSignal)) or 
//                                (trendilioTradeType == "OS/OB reverse" and (exitOB or bullishMomentumSignal)))

//     // Combined exit conditions - ADD FORCE_EXIT INTEGRATION HERE
//     bool longExitCondition = tradeActive and isLong and ((not force_exit and ((not stopLossDisabled and not na(entrySL) and low <= entrySL) or (takeProfitType != "None" and not na(entryTP) and high >= entryTP and close > entryPrice) or (earlyExitProtection and close < earlyExitMA) or t3ExitLong or waeExitLong or trendilioExitLong)) or(force_exit and ((useT3 and t3ExitLong) or (useWAE and waeExitLong) or (useTrendilio and trendilioExitLong) or not longCondition)))
    
//     bool shortExitCondition = tradeActive and not isLong and ((not force_exit and ((not stopLossDisabled and not na(entrySL) and high >= entrySL) or (takeProfitType != "None" and not na(entryTP) and low <= entryTP and close < entryPrice) or (earlyExitProtection and close > earlyExitMA) or t3ExitShort or waeExitShort or trendilioExitShort)) or (force_exit and ((useT3 and t3ExitShort) or (useWAE and waeExitShort) or (useTrendilio and trendilioExitShort) or not shortCondition)))

//     // Entry conditions for readability
//     bool longEntryValid = longCondition and canExecuteSignal and not waitForNewBarEntry and strategy.position_size == 0 and validLongEntry 
//     bool shortEntryValid = shortCondition and canExecuteSignal and not waitForNewBarEntry and strategy.position_size == 0 and validShortEntry

//     // ----------------------
//     // CUSTOM INDICATOR ALERTS
//     // ----------------------
//     // These alerts will notify when your custom indicators generate signals
    
//     // Custom Indicator 1 Alerts
//     if ActivateExternalComparison1 and allowFunctionCallAlerts and not alertSent_custom_indicator1
//         if (longComparison1 or shortComparison1) and canExecuteSignal
//             string alertMessage = getCustomIndicator1Template()
//             string formattedMessage = formatAlertMessage(alertMessage, 0, close, 0, 0, "Info")
//             triggerAlert(formattedMessage)
//             alertSent_custom_indicator1 := true
    
//     // Custom Indicator 2 Alerts
//     if ActivateExternalComparison2 and allowFunctionCallAlerts and not alertSent_custom_indicator2
//         if (longComparison2 or shortComparison2) and canExecuteSignal
//             string alertMessage = getCustomIndicator2Template()
//             string formattedMessage = formatAlertMessage(alertMessage, 0, close, 0, 0, "Info")
//             triggerAlert(formattedMessage)
//             alertSent_custom_indicator2 := true
     
//     // ----------------------
//     // ENTRY ALERTS
//     // ----------------------
//     // Long entry alert
//     if longEntryValid and not alertSent_entry_long
//         // First, get the correct alert message format
//         string alertMessage = getLongEntryTemplate()
        
//         if useMinimalistBot
//             // For Minimalist Bot: send only the alert (without strategy.entry)
//             triggerAlert(alertMessage)
//         else
//             // For Advanced Bot: Use Custom Entry and Exit fields
//             triggerAlert(i_alert_txt_entry_long )
            
//             // If we also need custom alerts beyond strategy alerts
//             if allowFunctionCallAlerts
//                 // Format the message correctly if it's not a MinimalistBot format
//                 string formattedMessage = formatAlertMessage(alertMessage, roundedQty, close, tpLong, slLong, "Buy")
//                 triggerAlert(formattedMessage)
        
//         // Mark alert as sent
//         alertSent_entry_long := true

//     // Short entry alert
//     if shortEntryValid and not alertSent_entry_short
//         // First, get the correct alert message format
//         string alertMessage = getShortEntryTemplate()
        
//         if useMinimalistBot
//             // For Minimalist Bot: send only the alert (without strategy.entry)
//             triggerAlert(alertMessage)
//         else
//             // For Advanced Bot: Use Custom Entry and Exit fields
//             triggerAlert(i_alert_txt_entry_short )
            
//             // If we also need custom alerts beyond strategy alerts
//             if allowFunctionCallAlerts
//                 // Format the message correctly if it's not a MinimalistBot format
//                 string formattedMessage = formatAlertMessage(alertMessage, roundedQty, close, tpShort, slShort, "Sell")
//                 triggerAlert(formattedMessage)
        
//         // Mark alert as sent
//         alertSent_entry_short := true

//     // ----------------------
//     // EXIT ALERTS
//     // ----------------------
//     // Long exit alert
//     if longExitCondition and canExecuteSignal and not alertSent_exit_long
//         // Get exit reason for better logging - IMPROVED FOR FORCE EXIT
//         string exitReason = "Exit Signal"  // Default reason
        
//         // Determine exit reason based on conditions
//         if force_exit and useT3 and t3ExitLong
//             exitReason := "T3 Force Exit"
//         else if force_exit and useWAE and waeExitLong
//             exitReason := "WAE Force Exit"
//         else if force_exit and useTrendilio and trendilioExitLong
//             exitReason := "Trendilio Force Exit"
//         else if force_exit
//             exitReason := "General Force Exit"
//         else if not stopLossDisabled and not na(entrySL) and low <= entrySL
//             exitReason := "Stop Loss"
//         else if takeProfitType != "None" and not na(entryTP) and high >= entryTP
//             exitReason := "Take Profit"
//         else if useT3 and t3ExitLong
//             exitReason := "T3 Exit"
//         else if useWAE and waeExitLong
//             exitReason := "WAE Exit"
//         else if useTrendilio and trendilioExitLong
//             exitReason := "Trendilio Exit"
//         else if earlyExitProtection and close < earlyExitMA
//             exitReason := "Early Exit Protection"
        
//         // Process exit with the determined reason
//         string alertMessage = getLongExitTemplate()
        
//         if useMinimalistBot
//             triggerAlert(alertMessage)
//         else
//             triggerAlert(i_alert_txt_exit_long)
//             if allowFunctionCallAlerts
//                 string formattedMessage = formatAlertMessage(alertMessage, strategy.position_size, close, 0, 0, "Sell")
//                 triggerAlert(formattedMessage)
        
//         // Position cleanup
//         alertSent_exit_long := true
//         lastExitBarIndex := bar_index
        
//         // Fix: Use the correct variable reference without the "Condition" suffix
//         if useTrendilio and trendilioExitLong
//             lastTrendilioExitBar := bar_index
        
//         waitForNewBarExit := true
//         currentPosition := "flat"
//         tradeActive := false

//     // Short exit alert
//     if shortExitCondition and canExecuteSignal and not alertSent_exit_short
//         // Use an appropriately named variable that doesn't shadow existing ones
//         string shortExitReason = "Exit Signal"  // Default reason
        
//         // Determine exit reason based on conditions
//         if force_exit and useT3 and t3ExitShort
//             shortExitReason := "T3 Force Exit"
//         else if force_exit and useWAE and waeExitShort
//             shortExitReason := "WAE Force Exit"
//         else if force_exit and useTrendilio and trendilioExitShort
//             shortExitReason := "Trendilio Force Exit"
//         else if force_exit
//             shortExitReason := "General Force Exit"
//         else if not stopLossDisabled and not na(entrySL) and high >= entrySL
//             shortExitReason := "Stop Loss"
//         else if takeProfitType != "None" and not na(entryTP) and low <= entryTP
//             shortExitReason := "Take Profit"
//         else if useT3 and t3ExitShort
//             shortExitReason := "T3 Exit"
//         else if useWAE and waeExitShort
//             shortExitReason := "WAE Exit"
//         else if useTrendilio and trendilioExitShort
//             shortExitReason := "Trendilio Exit"
//         else if earlyExitProtection and close > earlyExitMA
//             shortExitReason := "Early Exit Protection"
        
//         // Process exit with the determined reason
//         string shortAlertMessage = getShortExitTemplate()
        
//         if useMinimalistBot
//             triggerAlert(shortAlertMessage)
//         else
//             triggerAlert(i_alert_txt_entry_short)
            
//             if allowFunctionCallAlerts
//                 string formattedMessage = formatAlertMessage(shortAlertMessage, math.abs(strategy.position_size), close, 0, 0, "Buy")
//                 triggerAlert(formattedMessage)
        
//         // Position cleanup
//         alertSent_exit_short := true
//         lastExitBarIndex := bar_index
        
//         if useTrendilio and trendilioExitShort
//             lastTrendilioExitBar := bar_index
        
//         waitForNewBarExit := true
//         currentPosition := "flat"
//         tradeActive := false

//     // ----------------------
//     // SPECIAL CASE ALERTS
//     // ----------------------
//     // Planetary Hour Force Exit Alerts
//     if useForceExit and usePlanetaryFilter and tradeActive and bar_index > lastEntryCandle + forceExitWaitBars and canExecuteSignal
//         if isLong and strategy.position_size > 0 and forceExitLongPlanet != "None" and isPlanetHour(forceExitLongPlanet) and not alertSent_exit_long
//             // First, get the correct alert message format
//             string alertMessage = getLongExitTemplate()
            
//             if useMinimalistBot
//                 // For Minimalist Bot: send only the alert (without strategy.close)
//                 triggerAlert(alertMessage)
//             else
//                 triggerAlert(i_alert_txt_exit_long)
                
//                 // If we also need custom alerts beyond strategy alerts
//                 if allowFunctionCallAlerts
//                     // Format the message correctly if it's not a MinimalistBot format
//                     string formattedMessage = formatAlertMessage(alertMessage, strategy.position_size, close, 0, 0, "Sell")
//                     triggerAlert(formattedMessage)
            
//             // Mark alert as sent
//             alertSent_exit_long := true
        
//         if not isLong and strategy.position_size < 0 and forceExitShortPlanet != "None" and isPlanetHour(forceExitShortPlanet) and not alertSent_exit_short
//             // First, get the correct alert message format
//             string alertMessage = getShortExitTemplate()
            
//             if useMinimalistBot
//                 // For Minimalist Bot: send only the alert (without strategy.close)
//                 triggerAlert(alertMessage)
//             else
//                 // For Advanced Bot: Use custome Entry and Exit fields
//                 triggerAlert(i_alert_txt_exit_short)
                
//                 // If we also need custom alerts beyond strategy alerts
//                 if allowFunctionCallAlerts
//                     // Format the message correctly if it's not a MinimalistBot format
//                     string formattedMessage = formatAlertMessage(alertMessage, math.abs(strategy.position_size), close, 0, 0, "Buy")
//                     triggerAlert(formattedMessage)
            
//             // Mark alert as sent
//             alertSent_exit_short := true

//     // ----------------------
//     // REVERSAL MODE ALERTS
//     // ----------------------
//     // Implement reversal mode alerts properly
//     if reversalMode and canExecuteSignal and not waitForNewBarEntry
//         // Reversal from Short to Long
//         if longTrades and longCondition and strategy.position_size < 0 and not alertSent_entry_long
//             // First handle the exit portion of the reversal
//             string exitAlertMessage = getShortExitTemplate()
            
//             if useMinimalistBot
//                 // For Minimalist Bot: send only the alert (without strategy.close)
//                 triggerAlert(exitAlertMessage)
//             else
//                 // For Advanced Bot: Use custome Entry and Exit fields
//                 triggerAlert(i_alert_txt_exit_short)
                
//                 // If we also need custom alerts beyond strategy alerts
//                 if allowFunctionCallAlerts
//                     // Format the message correctly if it's not a MinimalistBot format
//                     string formattedExitMessage = formatAlertMessage(exitAlertMessage, math.abs(strategy.position_size), close, 0, 0, "Buy")
//                     triggerAlert(formattedExitMessage)
            
//             // Mark exit alert as sent
//             alertSent_exit_short := true
            
//             // Then handle the entry portion of the reversal
//             string entryAlertMessage = getLongEntryTemplate()
            
//             if useMinimalistBot
//                 // For Minimalist Bot: send only the alert (without strategy.entry)
//                 triggerAlert(entryAlertMessage)
//             else
//                 // For Advanced Bot: Use Custom Entry and Exit fields
//                 triggerAlert(i_alert_txt_entry_long )
                
//                 // If we also need custom alerts beyond strategy alerts
//                 if allowFunctionCallAlerts
//                     // Format the message correctly if it's not a MinimalistBot format
//                     string formattedEntryMessage = formatAlertMessage(entryAlertMessage, roundedQty, close, tpLong, slLong, "Buy")
//                     triggerAlert(formattedEntryMessage)
            
//             // Mark entry alert as sent
//             alertSent_entry_long := true
        
//         // Reversal from Long to Short
//         if shortTrades and shortCondition and strategy.position_size > 0 and not alertSent_entry_short
//             // First handle the exit portion of the reversal
//             string exitAlertMessage = getLongExitTemplate()
            
//             if useMinimalistBot
//                 // For Minimalist Bot: send only the alert (without strategy.close)
//                 triggerAlert(exitAlertMessage)
//             else
//                 // For Advanced Bot: Use custome Entry and Exit fields
//                 triggerAlert(i_alert_txt_exit_long )
                
//                 // If we also need custom alerts beyond strategy alerts
//                 if allowFunctionCallAlerts
//                     // Format the message correctly if it's not a MinimalistBot format
//                     string formattedExitMessage = formatAlertMessage(exitAlertMessage, strategy.position_size, close, 0, 0, "Sell")
//                     triggerAlert(formattedExitMessage)
            
//             // Mark exit alert as sent
//             alertSent_exit_long := true
            
//             // Then handle the entry portion of the reversal
//             string entryAlertMessage = getShortEntryTemplate()
            
//             if useMinimalistBot
//                 // For Minimalist Bot: send only the alert (without strategy.entry)
//                 triggerAlert(entryAlertMessage)
//             else
//                 // For Advanced Bot: Use Custom Entry and Exit fields
//                 triggerAlert(i_alert_txt_entry_short )
                
//                 // If we also need custom alerts beyond strategy alerts
//                 if allowFunctionCallAlerts
//                     // Format the message correctly if it's not a MinimalistBot format
//                     string formattedEntryMessage = formatAlertMessage(entryAlertMessage, roundedQty, close, tpShort, slShort, "Sell")
//                     triggerAlert(formattedEntryMessage)
            
//             // Mark entry alert as sent
//             alertSent_entry_short := true

//     // ----------------------
//     // MULTI TAKE PROFIT ALERTS
//     // ----------------------
//     // Implement multi take profit alerts
//     if useMultiTP and tradeActive and bar_index > lastEntryCandle and canExecuteSignal
//         // Skip take profits if we're in reversal mode with opposite signal
//         bool skipTP = reversalMode and ((isLong and shortCondition) or (not isLong and longCondition))
        
//         if not skipTP
//             if isLong and strategy.position_size > 0
//                 // Check if stop loss is hit first
//                 if not stopLossDisabled and not na(entrySL) and low <= entrySL and not alertSent_exit_long
//                     string alertMessage = getLongExitTemplate()
                    
//                     if useMinimalistBot
//                         // For Minimalist Bot: send only the alert (without strategy.close)
//                         triggerAlert(alertMessage)
//                     else
//                         // For Advanced Bot: Use custome Entry and Exit fields                      
//                         triggerAlert(i_alert_txt_exit_long )
                        
//                         // If we also need custom alerts beyond strategy alerts
//                         if allowFunctionCallAlerts
//                             // Format the message correctly if it's not a MinimalistBot format
//                             string formattedMessage = formatAlertMessage(alertMessage, strategy.position_size, close, 0, 0, "Sell")
//                             triggerAlert(formattedMessage)
                    
//                     // Mark alert as sent
//                     alertSent_exit_long := true
//                 else
//                     // TP1 for long positions
//                     if tp1Enabled and not tp1Reached and high >= tp1Price and bar_index != lastExitBarIndex and not alertSent_tp1_long
//                         float tpQty = roundedQty * (tp1Percent / 100)
//                         tpQty := math.max(f_round_qty(tpQty), 0.01)
                        
//                         string alertMessage = getTP1LongTemplate()
                        
//                         if useMinimalistBot
//                             // For Minimalist Bot: send only the alert (without strategy order)
//                             triggerAlert(alertMessage)
//                         else
//                             // For Advanced Bot: execute strategy.order (which will generate its own alert)
//                             alert_message_tp1_long := useMinimalistBot ? generateAlertJson("sell", tpQty, tp1Price, 0, 0, true) : i_alert_txt_tp1_long 
//                             strategy.order("TP1 Hit", strategy.short, qty=tpQty, alert_message=alert_message_tp1_long)
                            
//                             // If we also need custom alerts beyond strategy alerts
//                             if allowFunctionCallAlerts
//                                 // Format the message correctly if it's not a MinimalistBot format
//                                 string formattedMessage = formatAlertMessage(alertMessage, tpQty, tp1Price, 0, 0, "Sell")
//                                 triggerAlert(formattedMessage)
                        
//                         // Mark TP1 alert as sent and update status
//                         tp1Reached := true
//                         alertSent_tp1_long := true
                    
//                     // TP2 for long positions
//                     if tp2Enabled and not tp2Reached and high >= tp2Price and bar_index != lastExitBarIndex and not alertSent_tp2_long
//                         float tpQty = roundedQty * (tp2Percent / 100)
//                         tpQty := math.max(f_round_qty(tpQty), 0.01)
                        
//                         string alertMessage = getTP2LongTemplate()
                        
//                         if useMinimalistBot
//                             // For Minimalist Bot: send only the alert (without strategy order)
//                             triggerAlert(alertMessage)
//                         else
//                             // For Advanced Bot: execute strategy.order (which will generate its own alert)
//                             alert_message_tp2_long := useMinimalistBot ? generateAlertJson("sell", tpQty, tp2Price, 0, 0, true) : i_alert_txt_tp2_long
//                             strategy.order("TP2 Hit", strategy.short, qty=tpQty, alert_message=alert_message_tp2_long)
                            
//                             // If we also need custom alerts beyond strategy alerts
//                             if allowFunctionCallAlerts
//                                 // Format the message correctly if it's not a MinimalistBot format
//                                 string formattedMessage = formatAlertMessage(alertMessage, tpQty, tp2Price, 0, 0, "Sell")
//                                 triggerAlert(formattedMessage)
                        
//                         // Mark TP2 alert as sent and update status
//                         tp2Reached := true
//                         alertSent_tp2_long := true
                    
//                     // TP3 for long positions (final take profit)
//                     if not tp3Reached and high >= tp3Price and bar_index != lastExitBarIndex and not alertSent_tp3_long
//                         string alertMessage = getTP3LongTemplate()
                        
//                         if useMinimalistBot
//                             // For Minimalist Bot: send only the alert (without strategy close)
//                             triggerAlert(alertMessage)
//                         else
//                             // For Advanced Bot: Use custome Entry and Exit fields                           
//                             triggerAlert(i_alert_txt_exit_long)
                            
//                             // If we also need custom alerts beyond strategy alerts
//                             if allowFunctionCallAlerts
//                                 // Format the message correctly if it's not a MinimalistBot format
//                                 string formattedMessage = formatAlertMessage(alertMessage, strategy.position_size, tp3Price, 0, 0, "Sell")
//                                 triggerAlert(formattedMessage)
                        
//                         // Mark TP3 alert as sent and update status
//                         tp3Reached := true
//                         alertSent_tp3_long := true
//                         // Also set exit status since this is a full close
//                         alertSent_exit_long := true
                    
//             else if not isLong and strategy.position_size < 0
//                 // Check if stop loss is hit first
//                 if not stopLossDisabled and not na(entrySL) and high >= entrySL and not alertSent_exit_short
//                     string alertMessage = getShortExitTemplate()
                    
//                     if useMinimalistBot
//                         // For Minimalist Bot: send only the alert (without strategy.close)
//                         triggerAlert(alertMessage)
//                     else
//                         // For Advanced Bot: Use custome Entry and Exit fields
//                         triggerAlert(i_alert_txt_exit_short)
                        
//                         // If we also need custom alerts beyond strategy alerts
//                         if allowFunctionCallAlerts
//                             // Format the message correctly if it's not a MinimalistBot format
//                             string formattedMessage = formatAlertMessage(alertMessage, math.abs(strategy.position_size), close, 0, 0, "Buy")
//                             triggerAlert(formattedMessage)
                    
//                     // Mark alert as sent
//                     alertSent_exit_short := true
//                 else
//                     // TP1 for short positions
//                     if tp1Enabled and not tp1Reached and low <= tp1Price and bar_index != lastExitBarIndex and not alertSent_tp1_short
//                         float tpQty = roundedQty * (tp1Percent / 100)
//                         tpQty := math.max(f_round_qty(tpQty), 0.01)
                        
//                         string alertMessage = getTP1ShortTemplate()
                        
//                         if useMinimalistBot
//                             // For Minimalist Bot: send only the alert (without strategy order)
//                             triggerAlert(alertMessage)
//                         else
//                             // For Advanced Bot: execute strategy.order (which will generate its own alert)
//                             alert_message_tp1_short := useMinimalistBot ? generateAlertJson("buy", tpQty, tp1Price, 0, 0, false) : i_alert_txt_tp1_short 
//                             strategy.order("TP1 Hit", strategy.long, qty=tpQty, alert_message=alert_message_tp1_short)
                            
//                             // If we also need custom alerts beyond strategy alerts
//                             if allowFunctionCallAlerts
//                                 // Format the message correctly if it's not a MinimalistBot format
//                                 string formattedMessage = formatAlertMessage(alertMessage, tpQty, tp1Price, 0, 0, "Buy")
//                                 triggerAlert(formattedMessage)
                        
//                         // Mark TP1 alert as sent and update status
//                         tp1Reached := true
//                         alertSent_tp1_short := true
                    
//                     // TP2 for short positions
//                     if tp2Enabled and not tp2Reached and low <= tp2Price and bar_index != lastExitBarIndex and not alertSent_tp2_short
//                         float tpQty = roundedQty * (tp2Percent / 100)
//                         tpQty := math.max(f_round_qty(tpQty), 0.01)
                        
//                         string alertMessage = getTP2ShortTemplate()
                        
//                         if useMinimalistBot
//                             // For Minimalist Bot: send only the alert (without strategy order)
//                             triggerAlert(alertMessage)
//                         else
//                             // For Advanced Bot: execute strategy.order (which will generate its own alert)
//                             alert_message_tp2_short := useMinimalistBot ? generateAlertJson("buy", tpQty, tp2Price, 0, 0, false) : i_alert_txt_tp2_short 
//                             strategy.order("TP2 Hit", strategy.long, qty=tpQty, alert_message=alert_message_tp2_short)
                            
//                             // If we also need custom alerts beyond strategy alerts
//                             if allowFunctionCallAlerts
//                                 // Format the message correctly if it's not a MinimalistBot format
//                                 string formattedMessage = formatAlertMessage(alertMessage, tpQty, tp2Price, 0, 0, "Buy")
//                                 triggerAlert(formattedMessage)
                        
//                         // Mark TP2 alert as sent and update status
//                         tp2Reached := true
//                         alertSent_tp2_short := true
                    
//                     // TP3 for short positions (final take profit)
//                     if not tp3Reached and low <= tp3Price and bar_index != lastExitBarIndex and not alertSent_tp3_short
//                         string alertMessage = getTP3ShortTemplate()
                        
//                         if useMinimalistBot
//                             // For Minimalist Bot: send only the alert (without strategy close)
//                             triggerAlert(alertMessage)
//                         else
//                             // For Advanced Bot: Use custome Entry and Exit fields
//                             triggerAlert(i_alert_txt_tp3_short)
                            
//                             // If we also need custom alerts beyond strategy alerts
//                             if allowFunctionCallAlerts
//                                 // Format the message correctly if it's not a MinimalistBot format
//                                 string formattedMessage = formatAlertMessage(alertMessage, math.abs(strategy.position_size), tp3Price, 0, 0, "Buy")
//                                 triggerAlert(formattedMessage)
                        
//                         // Mark TP3 alert as sent and update status
//                         tp3Reached := true
//                         alertSent_tp3_short := true
//                         // Also set exit status since this is a full close
//                         alertSent_exit_short := true
                    
//     // ----------------------
//     // END OF SESSION ALERTS
//     // ----------------------
//     // Implement end of session alerts
//     if useSessions and isEndOfSession() and tradeActive and canExecuteSignal
//         // Close long position at end of session
//         if isLong and strategy.position_size > 0 and not alertSent_exit_long
//             string alertMessage = getLongExitTemplate()
            
//             if useMinimalistBot
//                 // For Minimalist Bot: send only the alert (without strategy.close)
//                 triggerAlert(alertMessage)
//             else
//                 // For Advanced Bot: Use custome Entry and Exit fields
//                 triggerAlert(i_alert_txt_exit_long )
                
//                 // If we also need custom alerts beyond strategy alerts
//                 if allowFunctionCallAlerts
//                     // Format the message correctly if it's not a MinimalistBot format
//                     string formattedMessage = formatAlertMessage(alertMessage, strategy.position_size, close, 0, 0, "Sell")
//                     triggerAlert(formattedMessage)
            
//             // Mark alert as sent
//             alertSent_exit_long := true
        
//         // Close short position at end of session
//         if not isLong and strategy.position_size < 0 and not alertSent_exit_short
//             string alertMessage = getShortExitTemplate()
            
//             if useMinimalistBot
//                 // For Minimalist Bot: send only the alert (without strategy.close)
//                 triggerAlert(alertMessage)
//             else
//                 // For Advanced Bot: Use custome Entry and Exit fields
//                 triggerAlert(i_alert_txt_exit_short)
                
//                 // If we also need custom alerts beyond strategy alerts
//                 if allowFunctionCallAlerts
//                     // Format the message correctly if it's not a MinimalistBot format
//                     string formattedMessage = formatAlertMessage(alertMessage, math.abs(strategy.position_size), close, 0, 0, "Buy")
//                     triggerAlert(formattedMessage)
            
//             // Mark alert as sent
//             alertSent_exit_short := true
             
//------------------
// MONTHLY PNL LOGIC 
//------------------
// Month names array
var month_names = array.from("Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec")

// Color options
loss_colour = color.red
win_colour = color.green
cell_text_colour = color.white

// Enhanced approach for consistent PNL tracking across all timeframes
var year_array = array.new_int(0)     // Array to store years
var month_array = array.new_int(0)    // Array to store months
var pnl_array = array.new_float(0)    // Array to store corresponding PNL values
var trade_count_array = array.new_int(0)  // New array to track if trades happened this month
var initialization_done = false

// Current year and month
int current_year = year(time)
int current_month = month(time)

// Get strategy equity and compare to previous bar
eq = strategy.equity
float bar_pnl = 0.0

// Only calculate bar_pnl after first bar to avoid division by zero
if bar_index > 0
    bar_pnl := eq / eq[1] - 1

// Helper function to find index of year-month in arrays
findYearMonthIndex(int yr, int mn) =>
    int index = -1
    int size = array.size(year_array)
    
    if size > 0  // Only search if arrays are not empty
        for i = 0 to size - 1
            if array.get(year_array, i) == yr and array.get(month_array, i) == mn
                index := i
                break
    index

// Initialize arrays on first bar
if not initialization_done and bar_index == 0
    array.push(year_array, current_year)
    array.push(month_array, current_month)
    array.push(pnl_array, 0.0)
    array.push(trade_count_array, 0)  // Initialize trade count to 0
    initialization_done := true

// Track when trades happen (entries or exits)
bool trade_happened = strategy.opentrades != strategy.opentrades[1] or (strategy.closedtrades.exit_bar_index(strategy.closedtrades - 1) == bar_index and strategy.closedtrades > 0)

// Then for each bar, update PNL for current month
if bar_index > 0  // Skip first bar when calculating performance
    // Check if we have an entry for the current year-month
    int current_index = findYearMonthIndex(current_year, current_month)

    // If we don't have an entry for this year-month yet, create one
    if current_index == -1
        array.push(year_array, current_year)
        array.push(month_array, current_month)
        array.push(pnl_array, 0.0)  // Initialize with 0 PNL
        array.push(trade_count_array, 0)  // Initialize trade count to 0
        current_index := array.size(year_array) - 1

    // Update the PNL for current month
    float current_pnl = array.get(pnl_array, current_index)
    float updated_pnl = (1 + current_pnl) * (1 + bar_pnl) - 1
    array.set(pnl_array, current_index, updated_pnl)
    
    // Update trade count if a trade happened on this bar
    if trade_happened
        array.set(trade_count_array, current_index, array.get(trade_count_array, current_index) + 1)
    

//-----------------------
// CREATE AND RENDER THE TABLE IF showTable == true
//-----------------------
if showTable and not optimizingTime
    // Create table with fixed size to avoid bounds issues
    var pnl_table = table.new(position.bottom_right, columns=13, rows=25, border_width=1, bgcolor=color.new(color.black, 10))
    
    // Headers
    table.cell(pnl_table, 0, 0, "Year", bgcolor=color.new(color.navy, 10), text_color=color.white, text_size=size.small)
    for i = 0 to 11
        table.cell(pnl_table, i + 1, 0, array.get(month_names, i), bgcolor=color.new(color.navy, 10), text_color=color.white, text_size=size.small)
    
    // Get all unique years from the stored data
    var display_years = array.new_int(0)
    array.clear(display_years)
    
    // Extract all unique years
    for i = 0 to array.size(year_array) - 1
        int yr = array.get(year_array, i)
        if array.indexof(display_years, yr) == -1
            array.push(display_years, yr)
    
    // Sort years in descending order
    if array.size(display_years) > 0
        array.sort(display_years, order.descending)
    
    // Populate table for each year
    for row = 0 to math.min(array.size(display_years) - 1, 15)  // Limit to 16 rows (0-15)
        int yr = array.get(display_years, row)
        
        // Populate year cell
        table.cell(pnl_table, 0, row + 1, str.tostring(yr), bgcolor=color.new(color.gray, 20), text_color=color.white, text_size=size.small)
        
        // Fill in monthly data for this year
        for month_idx = 1 to 12
            // Skip future months in current year
            if yr == current_year and month_idx > current_month
                table.cell(pnl_table, month_idx, row + 1, "", bgcolor=color.new(color.gray, 70), text_size=size.small)
                continue
            
            // Find PNL for this month
            int month_data_index = findYearMonthIndex(yr, month_idx)
            float m_pnl = 0.0
            bool found_month = false
            int trade_count = 0
            
            if month_data_index >= 0
                m_pnl := array.get(pnl_array, month_data_index)
                trade_count := array.get(trade_count_array, month_data_index)
                found_month := true
            
            // Render month cell
            if found_month
                if trade_count > 0 and m_pnl != 0
                    // Month with trades - show PNL value
                    color cell_bg = m_pnl > 0 ? color.new(color.green, 20) : color.new(color.red, 20)
                    table.cell(pnl_table, month_idx, row + 1,
                              str.tostring(math.round(m_pnl * 100, prec)),
                              bgcolor=cell_bg, text_color=color.white, text_size=size.small)
                else if yr != current_year or month_idx < current_month
                    // Past month with no trades - show NoN
                    table.cell(pnl_table, month_idx, row + 1, "NA", bgcolor=color.new(color.gray, 50), text_color=color.white, text_size=size.small)
                else
                    // Current month with no trades yet - show 0
                    table.cell(pnl_table, month_idx, row + 1, "0", bgcolor=color.new(color.gray, 70), text_size=size.small)
            else if yr != current_year
                // Year in our history but no data for this month - show NoN
                table.cell(pnl_table, month_idx, row + 1, "NA", bgcolor=color.new(color.gray, 50), text_color=color.white, text_size=size.small)
            else
                // Current year but no data yet for this month - show 0
                table.cell(pnl_table, month_idx, row + 1, "0", bgcolor=color.new(color.gray, 70), text_size=size.small)
